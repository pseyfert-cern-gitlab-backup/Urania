/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TransF5.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(TransF5) 


 TransF5::TransF5(const TransF5& other, const char* name) :  
   RooAbsReal(other,name), 
   m_useX(other.m_useX),
   CPsi("CPsi",this,other.CPsi),
   CTheta("CTheta",this,other.CTheta),
   Phi("Phi",this,other.Phi),
   X("X",this,other.X)
 { 
 } 



 Double_t TransF5::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   Double_t CPsi2 = CPsi*CPsi;
   Double_t SPsi2 = 1 - CPsi2;
   Double_t SPsi = sqrt(SPsi2);
   Double_t CTheta2 = CTheta*CTheta;
   Double_t STheta2 = 1-CTheta2;
   Double_t CPhi = cos(Phi);
   Double_t SPhi = sin(Phi);
   Double_t CPhi2 = CPhi*CPhi;
   Double_t SPhi2 = SPhi*SPhi;

   return sqrt(2.)*SPsi*CPsi*STheta2*2.*SPhi*CPhi ; 
 } 



 Int_t TransF5::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 
   if (matchArgs(allVars,analVars,CPsi,CTheta,Phi)) return 4 ;
   if (matchArgs(allVars,analVars,CPsi,CTheta    )) return 2 ;
   if (matchArgs(allVars,analVars,CPsi,       Phi)) return 3 ;
   if (matchArgs(allVars,analVars,     CTheta,Phi)) return 6 ;
   if (matchArgs(allVars,analVars,CPsi           )) return 1 ;
   if (matchArgs(allVars,analVars,     CTheta    )) return 5 ;
   if (matchArgs(allVars,analVars,            Phi)) return 7 ;
   
   return 0 ; 
 } 



 Double_t TransF5::analyticalIntegral(Int_t code, const char* range) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 

//    cout << "TransF5" << endl;
//    cout << "Integral Codigo: "<< code << endl;
//    cout << "UseX is:  " << m_useX<< endl;
//    cout << "X is: " << X << endl;

   if(useX()) return X;

        double p2;
        if (code>0 && code<5) {
          double hi = CPsi.max(range);
          double lo = CPsi.min(range);
          double x=1-hi*hi; double y=1-lo*lo;
          p2 = -x*sqrt(x)+y*sqrt(y); p2*=2; p2/=3;         // integral of sin (2psi)
        } else {
          double p0 = CPsi; p0*=p0;
          double p1 = 1-p0;
          p2 = 2.*CPsi*sqrt(p1);
        }
  
        double ist2;
        if ((code>3 && code<7) || code==2) {
          double hi = CTheta.max(range);
          double lo = CTheta.min(range);
          double it = hi-lo;                             // integral of 1
          double ict2 = pow(hi,3)-pow(lo,3); ict2/=3;    // integral of cos^2 theta
          ist2 = it-ict2;                                // integral of sin^2 theta 
        } else {
          ist2 = 1-CTheta*CTheta;
        }
  
        double is2p;
        if (code==3 || code==4 || code==6 || code==7) {
          double rc2p = cos(2.*Phi.max(range)) - cos(2.*Phi.min());
          is2p = -rc2p/2;
        } else {
          is2p = sin(2*Phi);
        }
        return  + p2 * ist2*is2p /sqrt(2.);//opposite (minus) sign: BaBar convention


 } 



