/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TransF7.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(TransF7) 



 TransF7::TransF7(const TransF7& other, const char* name) :  
   RooAbsReal(other,name), 
   m_useX(other.m_useX),
   CPsi("CPsi",this,other.CPsi),
   CTheta("CTheta",this,other.CTheta),
   Phi("Phi",this,other.Phi),
   X("X",this,other.X)
 { 
 } 



 Double_t TransF7::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t CPsi2 = CPsi*CPsi;
   Double_t SPsi2 = 1 - CPsi2;
   Double_t SPsi = sqrt(SPsi2);
   Double_t CTheta2 = CTheta*CTheta;
   Double_t STheta2 = 1-CTheta2;
   Double_t CPhi = cos(Phi);
   Double_t SPhi = sin(Phi);
   Double_t CPhi2 = CPhi*CPhi;
   Double_t SPhi2 = SPhi*SPhi;


   return 2./3.*(1-STheta2*CPhi2);


 } 



 Int_t TransF7::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 

   if (matchArgs(allVars,analVars,CPsi,CTheta,Phi)) return 4 ;
   if (matchArgs(allVars,analVars,CPsi,CTheta    )) return 2 ;
   if (matchArgs(allVars,analVars,CPsi,       Phi)) return 3 ;
   if (matchArgs(allVars,analVars,     CTheta,Phi)) return 6 ;
   if (matchArgs(allVars,analVars,CPsi           )) return 1 ;
   if (matchArgs(allVars,analVars,     CTheta    )) return 5 ;
   if (matchArgs(allVars,analVars,            Phi)) return 7 ;

   return 0 ; 
 } 



 Double_t TransF7::analyticalIntegral(Int_t code, const char* range) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 

   if(useX()) return X;

   double p0;
   if (code>0 && code<5) { // integrate
     const double hi = CPsi.max(range);
     const double lo = CPsi.min(range);
     p0 = hi-lo;                   // integral of cos^2 psi
   } else {                    // multiply by value...
     p0 = 1;
   }
   double it,ist2;
   if ((code>3 && code<7) || code==2) { // integrate
     const double hi = CTheta.max(range);
     const double lo = CTheta.min(range);
     it = hi-lo;                                        // integral of 1
     double ict2 = pow(hi,3)-pow(lo,3); ict2/=3;        // integral of cos^2 theta
     ist2 = it-ict2;                                    // integral of sin^2 theta
   } else {                      // value
     it = 1;
     ist2 = 1-CTheta*CTheta;
   }
   double ip,icp2;
   if (code==3 || code==4 || code==6 || code==7) {
     ip = Phi.max(range)-Phi.min(range);
     const double rs2p = sin(2.*Phi.max(range)) - sin(2.*Phi.min(range));
     icp2 = ip/2+rs2p/4;
   } else {
     ip = 1;
     icp2 = cos(Phi); icp2*=icp2;
   }
   //This is the 3D integral over cpsi,ctheta and phi of the function F1 = 2/3*(1-(1-ctheta*ctheta)*cphi*cphi). 
   return 2/3.*p0*(it*ip-ist2*icp2);
  
 } 



