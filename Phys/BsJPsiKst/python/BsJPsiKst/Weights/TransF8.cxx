/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TransF8.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(TransF8) 



 TransF8::TransF8(const TransF8& other, const char* name) :  
   RooAbsReal(other,name), 
   m_useX(other.m_useX),
   CPsi("CPsi",this,other.CPsi),
   CTheta("CTheta",this,other.CTheta),
   Phi("Phi",this,other.Phi),
   X("X",this,other.X)
 { 
 } 



 Double_t TransF8::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t CPsi2 = CPsi*CPsi;
   Double_t SPsi2 = 1 - CPsi2;
   Double_t SPsi = sqrt(SPsi2);
   Double_t CTheta2 = CTheta*CTheta;
   Double_t STheta2 = 1-CTheta2;
   Double_t CPhi = cos(Phi);
   Double_t SPhi = sin(Phi);
   Double_t CPhi2 = CPhi*CPhi;
   Double_t SPhi2 = SPhi*SPhi;


   return sqrt(6.)/3.*SPsi*STheta2*2.*SPhi*CPhi; // F8 = sqrt(6.)/3.*sqrt(1-cpsi*cpsi)*(1-ctheta*ctheta)*sin(2phi) 
 } 



 Int_t TransF8::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 
   if (matchArgs(allVars,analVars,CPsi,CTheta,Phi)) return 4 ;
   if (matchArgs(allVars,analVars,CPsi,CTheta    )) return 2 ;
   if (matchArgs(allVars,analVars,CPsi,       Phi)) return 3 ;
   if (matchArgs(allVars,analVars,     CTheta,Phi)) return 6 ;
   if (matchArgs(allVars,analVars,CPsi           )) return 1 ;
   if (matchArgs(allVars,analVars,     CTheta    )) return 5 ;
   if (matchArgs(allVars,analVars,            Phi)) return 7 ;
   
   return 0 ; 
 } 



 Double_t TransF8::analyticalIntegral(Int_t code, const char* range) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 

   if(useX()) return X;

   double p0;
   if (code>0 && code<5) { // integrate
     const double hi = CPsi.max(range);
     const double lo = CPsi.min(range);
     double x1 = sqrt(1-hi*hi)*hi; double y1 = sqrt(1-lo*lo)*lo;
     double x2 = asin(hi); double y2 = asin(lo);
     p0 = (x1 + x2) - (y1 + y2); p0/=2;
   } else {                    // multiply by value...
     p0 = sqrt(1-CPsi*CPsi);
   }
   double it,ist2;
   if ((code>3 && code<7) || code==2) { // integrate
     const double hi = CTheta.max(range);
     const double lo = CTheta.min(range);
     it = hi-lo;                                        // integral of 1
     double ict2 = pow(hi,3)-pow(lo,3); ict2/=3;        // integral of cos^2 theta
     ist2 = it-ict2;                                    // integral of sin^2 theta
   } else {                      // value
     it = 1;
     ist2 = 1-CTheta*CTheta;
   }
   double ip,icp2;
   if (code==3 || code==4 || code==6 || code==7) {
     const double rs2p = cos(2.*Phi.min(range)) - cos(2.*Phi.max(range));
     icp2 = rs2p;
   } else {
     ip = 1;
     icp2 = sin(2*Phi);
   }
   //This is the 3D integral over cpsi,ctheta and phi of the function F8 = sqrt(6.)/3.*sqrt(1-cpsi*cpsi)*(1-ctheta*ctheta)*sin(2phi)
   return sqrt(6.)/3.*p0*(it*ist2)*icp2;
    
 } 



