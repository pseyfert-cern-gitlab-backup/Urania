/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "AngMassTerm.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "Math/SpecFuncMathMore.h"
#include "Math/SpecFunc.h"

#include "AllAngFunctions.C"
#include "AllMassFunctions.C"
#include "AllAmplitudes.C"

#include "RooArgList.h"
#include "TTree.h"
#include "TF1.h"

using namespace std;



ClassImp(AngMassTerm) 

 AngMassTerm::AngMassTerm(const char *name, const char *title, 
			Int_t _indx,
		        RooAbsReal& _c1,
                        RooAbsReal& _c2,
                        RooAbsReal& _ph,
                        RooAbsReal& _m1,
                        RooAbsReal& _m2,
                        RooAbsReal& _fL,
                        RooAbsReal& _fpa,
                        RooAbsReal& _Asp2,
                        RooAbsReal& _Asm2,
                        RooAbsReal& _Ass2,
                        RooAbsReal& _dpa,
                        RooAbsReal& _dpe,
                        RooAbsReal& _dsp,
                        RooAbsReal& _dsm,
                        RooAbsReal& _dss,
                        RooAbsReal& _m_kst,
                        RooAbsReal& _m_kst0,
                        RooAbsReal& _g_kst,
                        RooAbsReal& _g_kst0,
                        RooAbsReal& _m_Bs,
                        RooAbsReal& _Gs,
                        RooAbsReal& _DGs,
                        RooAbsReal& _norm,
                        RooAbsReal& _normP,
                        RooAbsReal& _normS,
                          RooAbsReal& _normSS,
                          // char *_treename,
                          			TTree *tin,
			char *_branchname) :
   RooAbsReal(name,title), 
   c1("c1","c1",this,_c1),
   c2("c2","c2",this,_c2),
   ph("ph","ph",this,_ph),
   m1("m1","m1",this,_m1),
   m2("m2","m2",this,_m2),
   fL("fL","fL",this,_fL),
   fpa("fpa","fpa",this,_fpa),
   Asp2("Asp2","Asp2",this,_Asp2),
   Asm2("Asm2","Asm2",this,_Asm2),
   Ass2("Ass2","Ass2",this,_Ass2),
   dpa("dpa","dpa",this,_dpa),
   dpe("dpe","dpe",this,_dpe),
   dsp("dsp","dsp",this,_dsp),
   dsm("dsm","dsm",this,_dsm),
   dss("dss","dss",this,_dss),
   m_kst("m_kst","m_kst",this,_m_kst),
   m_kst0("m_kst0","m_kst0",this,_m_kst0),
   g_kst("g_kst","g_kst",this,_g_kst),
   g_kst0("g_kst0","g_kst0",this,_g_kst0),
   m_Bs("m_Bs","m_Bs",this,_m_Bs),
   Gs("Gs","Gs",this,_Gs),
   DGs("DGs","DGs",this,_DGs),
   norm("norm","norm",this,_norm),
   normP("normP","normP",this,_normP),
   normS("normS","normS",this,_normS),
   normSS("normSS","normSS",this,_normSS)
 { 

   indx = _indx;
   // TFile fin(_treename);   
   // TTree *tin = (TTree*)fin.Get("acc5D");
   // tin->SetBranchAddress(_branchname,&acc_coeffs);
   // tin->GetEntry(0);
   

   // delete tin;
   // fin.Close();
   

   // cout<<"I got this far"<<endl;
   
   double _acc_coeffs[MYA][MYB][MYC][MYD][MYF];
   tin->SetBranchAddress(_branchname,&_acc_coeffs);
   tin->GetEntry(0);

   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
         for (Int_t n=0;n<orders[3];n++){
           for (Int_t m=0;m<orders[4];m++){

             acc_coeffs[i + j*MYA + l*MYA*MYB + n*MYA*MYB*MYC +m*MYA*MYB*MYC*MYD] = _acc_coeffs[i][j][l][n][m];


           }
         }
       }
     }
   }
  
 }


 


 AngMassTerm::AngMassTerm(const AngMassTerm& other, const char* name) :  
   RooAbsReal(other,name), 
   c1("c1",this,other.c1),
   c2("c2",this,other.c2),
   ph("ph",this,other.ph),
   m1("m1",this,other.m1),
   m2("m2",this,other.m2),
   fL("fL",this,other.fL),
   fpa("fpa",this,other.fpa),
   Asp2("Asp2",this,other.Asp2),
   Asm2("Asm2",this,other.Asm2),
   Ass2("Ass2",this,other.Ass2),
   dpa("dpa",this,other.dpa),
   dpe("dpe",this,other.dpe),
   dsp("dsp",this,other.dsp),
   dsm("dsm",this,other.dsm),
   dss("dss",this,other.dss),
   m_kst("m_kst",this,other.m_kst),
   m_kst0("m_kst0",this,other.m_kst0),
   g_kst("g_kst",this,other.g_kst),
   g_kst0("g_kst0",this,other.g_kst0),
   m_Bs("m_Bs",this,other.m_Bs),
   Gs("Gs",this,other.Gs),
   DGs("DGs",this,other.DGs),
   norm("norm",this,other.norm),
   normP("normP",this,other.normP),
   normS("normS",this,other.normS),
   normSS("normSS",this,other.normSS)
 { 

   indx = other.indx;

   // Int_t orders[MYDIM];
   // orders[0] = MYA; orders[1] = MYB;
   // for (Int_t i=0;i<orders[0];i++){
   //   for (Int_t j=0;j<orders[1];j++){

   //     acc_coeffs[i][j] = other.acc_coeffs[i][j];
   //     cout<<"acc_coeff_"<<i<<j<<" = "<<acc_coeffs[i][j]<<endl;
   //   }
   // }

   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
         for (Int_t n=0;n<orders[3];n++){
           for (Int_t m=0;m<orders[4];m++){

             acc_coeffs[i + j*MYA + l*MYA*MYB + n*MYA*MYB*MYC +m*MYA*MYB*MYC*MYD] = other.acc_coeffs[i + j*MYA + l*MYA*MYB + n*MYA*MYB*MYC +m*MYA*MYB*MYC*MYD];


           }
         }
       }
     }
   }

 } 


double AngMassTerm::get_Acceptance() const 
{

  double Y_nm= 0.; double P_i= 0; double P_j= 0; double P_l= 0;
  double Eff = 0.;
  double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
  double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);


  int orders[MYDIM];
  orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
  for (int i=0;i<orders[0];i++){
    for (int j=0;j<orders[1];j++){
      for (int l=0;l<orders[2];l++){
	for (int n=0;n<orders[3];n++){
	  for (int m=0;m<orders[4];m++){
	    //           if (i==0 && j==1 && n==3 && m==1) cout <<"C_"<<i<<j<<l<<n<<m<<" = "<<acc_coeffs[i][j][l][n][m]<<endl;
	    //cout<< "P_i" << endl;                                                                                                                                                      
	    P_i  = ROOT::Math::legendre(i,m1_red);//gsl_sf_legendre_Pl(i,m1_red);                                                                                                        
	    //cout<< "P_j" << endl;                                                                                                                                                      
	    P_j  = ROOT::Math::legendre(j,m2_red);//gsl_sf_legendre_Pl(j,m2_red);                                                                                                        
	    //cout<< "P_l" << endl;                                                                                                                                                      
	    P_l  = ROOT::Math::legendre(l,c1);//gsl_sf_legendre_Pl(l,c1);                                                                                                                
	    //cout<< "Y_nm" << endl;                                                                                                                                                     
	    if ( m>n ) continue;
	    else if ( m == 0 ) Y_nm = ROOT::Math::sph_legendre(n,m,c2);//gsl_sf_legendre_sphPlm (n,m,c2);                                                                                
	    else          Y_nm = sqrt(2) * ROOT::Math::sph_legendre(n,m,c2) * cos(m*ph);//sqrt(2) * gsl_sf_legendre_sphPlm(n,m,c2) * cos(m*ph); 
	    
// 	    cout <<"C_"<<i<<j<<l<<n<<m<<" = "<< acc_coeffs[i][j][l][n][m] << endl;

	    Eff += acc_coeffs[i + j*MYA + l*MYA*MYB + n*MYA*MYB*MYC +m*MYA*MYB*MYC*MYD]*(P_i*P_j*P_l* Y_nm);
           }
         }
       }
     }
   }

//    cout<<"Salgo de aqui..."<<endl;                                                                                                                                                     
     return Eff;

}



 Double_t AngMassTerm::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   //Time integrated amplitudes
   Double_t Kindx = get_Amplitude(indx,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,norm);

   // Mass amplitudes
   Double_t Mindx = get_MassTerm(indx,m1,m2,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,m_kst,m_kst0,g_kst,g_kst0,m_Bs,normP,normS,normSS);   

   // Angular Amplitudes
   Double_t findx = get_AngTerm(indx,c1,c2,ph);

   // Products
   Double_t product = Mindx*findx*Kindx;


   Double_t acc = get_Acceptance();


   Double_t val = product*acc;

   return val;
 } 



 Int_t AngMassTerm::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 

//    if (matchArgs(allVars,analVars,c1,c2,ph,m1))
//      {
//        if (matchArgs(allVars,analVars,m2)) return 1 ;
//      }
//    if (matchArgs(allVars,analVars,c1,c2,ph,m1   )) return 2 ;
//    if (matchArgs(allVars,analVars,c1,c2,ph   ,m2)) return 3 ;
//    if (matchArgs(allVars,analVars,c1,c2,   m1,m2)) return 4 ;
//    if (matchArgs(allVars,analVars,c1,   ph,m1,m2)) return 5 ;
//    if (matchArgs(allVars,analVars,   c2,ph,m1,m2)) return 6 ;
   
//    if (matchArgs(allVars,analVars,c1,c2,ph)) return 7 ;
//    if (matchArgs(allVars,analVars,c1,c2,m1)) return 8 ;
//    if (matchArgs(allVars,analVars,c1,c2,m2)) return 9 ;
//    if (matchArgs(allVars,analVars,c1,ph,m1)) return 10 ;
//    if (matchArgs(allVars,analVars,c1,ph,m2)) return 11 ;
//    if (matchArgs(allVars,analVars,c1,m1,m2)) return 12 ;
//    if (matchArgs(allVars,analVars,c2,ph,m1)) return 13 ;
//    if (matchArgs(allVars,analVars,c2,ph,m2)) return 14 ;
//    if (matchArgs(allVars,analVars,c2,m1,m2)) return 15 ;
//    if (matchArgs(allVars,analVars,ph,m1,m2)) return 16 ;

//    if (matchArgs(allVars,analVars,c1,c2)) return 17 ;
//    if (matchArgs(allVars,analVars,c1,ph)) return 18 ;
//    if (matchArgs(allVars,analVars,c1,m1)) return 19 ;
//    if (matchArgs(allVars,analVars,c1,m2)) return 20 ;
//    if (matchArgs(allVars,analVars,c2,ph)) return 21 ;
//    if (matchArgs(allVars,analVars,c2,m1)) return 22 ;
//    if (matchArgs(allVars,analVars,c2,m2)) return 23 ;
//    if (matchArgs(allVars,analVars,ph,m1)) return 24 ;
//    if (matchArgs(allVars,analVars,ph,m2)) return 25 ;
//    if (matchArgs(allVars,analVars,m1,m2)) return 26 ;

//    if (matchArgs(allVars,analVars,c1)) return 27 ;
//    if (matchArgs(allVars,analVars,c2)) return 28 ;
//    if (matchArgs(allVars,analVars,ph)) return 29 ;
//    if (matchArgs(allVars,analVars,m1)) return 30 ;
//    if (matchArgs(allVars,analVars,m2)) return 31 ;


   TIterator* iter_all = allVars.createIterator();
   TIterator* iter_ana = analVars.createIterator();
//    int size_all = allVars -> getSize();
//    int size_anal = analVars -> getSize();

   RooAbsArg* variable;

   while((variable = (RooAbsArg*)iter_all->Next())) {

     cout<<"allVars element: "<<variable->GetName()<<endl;
       }

   while((variable = (RooAbsArg*)iter_ana->Next())) {

     cout<<"analVars element: "<<variable->GetName()<<endl;
       }


   RooArgSet emptyset;
   RooAbsArg *var;

   if (matchArgs(allVars,emptyset,c1,c2,ph,m1))
     {
       if (matchArgs(allVars,analVars,m2)){
	
	 TIterator* iter_empty = emptyset.createIterator();
	 while((var = (RooAbsArg*)iter_empty->Next())) {

	   analVars.add(*var);
	 }
       
	 return 1 ;
       }
     }

   if (matchArgs(allVars,analVars,   c2,ph,m1,m2)) return 6 ;

   if (matchArgs(allVars,analVars,c1,c2,ph)) return 7 ;

   if (matchArgs(allVars,analVars,c2,ph)) return 21 ;
   if (matchArgs(allVars,analVars,m1,m2)) return 26 ;


   return 0 ; 
 } 



 Double_t AngMassTerm::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 


   //Time integrated amplitudes
   Double_t Kindx = get_Amplitude(indx,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,norm);

   // Mass amplitudes
   Double_t Mindx = get_MassTerm(indx,m1,m2,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,m_kst,m_kst0,g_kst,g_kst0,m_Bs,normP,normS,normSS);   

   // Angular Amplitudes
   Double_t findx = get_AngTerm(indx,c1,c2,ph);


   double fangular[MYC][MYD][MYF];
   double fmass[MYA][MYB];


   double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
   double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);

   double iY_nm[MYD][MYF];
   double iY_m[MYF];
   double iP_i[MYA];
   double iP_j[MYB];
   double iP_l[MYC];

   TF1 *P_i = new TF1("P_i","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *P_j = new TF1("P_j","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *P_l = new TF1("P_l","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *Y_nm = new TF1("Y_nm","ROOT::Math::sph_legendre([0],[1],acos(x))",-1,1);
   TF1 *C_m = new TF1("P_m","cos([0]*x)",0.,2*TMath::Pi());
 
   for (int i_=0; i_<MYA; i_++)
     {
       P_i->SetParameter(0,i_);
       iP_i[i_]=P_i->Eval(m1_red);
     
       for (int j_=0; j_<MYB; j_++)
	 {
	   P_j->SetParameter(0,j_);
	   iP_j[j_]=P_j->Eval(m2_red);
	   
	   fmass[i_][j_] = Mindx*iP_i[i_]*iP_j[j_];
	 }
     }
   for (int l_=0; l_<MYC; l_++)
     {
       P_l->SetParameter(0,l_);
       iP_l[l_]=P_l->Eval(c1);
       
       for (int n_=0; n_<MYD; n_++)
	 {
	   for (int m_=0; m_<MYF; m_++)
	     {
	       if(m_>n_) continue;
	       Y_nm->SetParameter(0,n_);
	       Y_nm->SetParameter(1,m_);
	       iY_nm[n_][m_]=Y_nm->Eval(c2);
	       if (m_==0) iY_m[m_]=1;
	       else{
		 C_m->SetParameter(0,m_);
		 iY_m[m_]=sqrt(2)*(C_m->Eval(ph));
	       }
	       fangular[l_][n_][m_] = findx*iP_l[l_]*iY_nm[n_][m_]*iY_m[m_];
	     }}}



   if (code==1 || code==7)
     {
       //Integrate over c1&c2&phi
       
       for (int ll=0; ll<MYC; ll++)
	 {
	   for (int nn=0; nn<MYD; nn++)
	     {
	       for (int mm=0; mm<MYF; mm++)
		 {
		   if(mm>nn) continue;
		   
		   fangular[ll][nn][mm] = get_AngTerm_Integral(indx, ll, nn, mm );
		   
		 }}
	 }
  
     }

   if (code==6 || code==21)
     {
       //Integrate over c2&phi
       for (int ll=0; ll<MYC; ll++)
	 {
	   for (int nn=0; nn<MYD; nn++)
	     {
	       for (int mm=0; mm<MYF; mm++)
		 {
		   if(mm>nn) continue;
		   
		   fangular[ll][nn][mm] = iP_l[ll]*get_AngTerm_Integral_c2_ph(indx, c1, nn, mm );
		   
		 }}
	 }
     }       




   if (code==1 || code==6 || code==26)
     {

       for (int ii=0; ii<MYA; ii++)
	 {
	   for (int jj=0; jj<MYB; jj++)
	     {

	       fmass[ii][jj] = get_MassTerm_Integral(indx, fL, fpa, Asp2, Asm2, Ass2, dpa, dpe, dsp, dsm, dss, 
						     Gs, DGs, m_kst, m_kst0, g_kst, g_kst0 , m_Bs, normP, normS, normSS, 
						     ii, jj);

	     }
	 }

     }



   Double_t iAngMass=0;
   
   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
	 for (Int_t n=0;n<orders[3];n++){
	   for (Int_t m=0;m<orders[4];m++){

	     if (m>n) continue;
	     
	     iAngMass+= acc_coeffs[i + j*MYA + l*MYA*MYB + n*MYA*MYB*MYC +m*MYA*MYB*MYC*MYD]*fangular[l][n][m]*fmass[i][j]*Kindx;

	   }
	 }
       }
     }
   }

   

//    delete iY_nm;
//    delete iY_m;
//    delete iP_i;
//    delete iP_j;
//    delete iP_l;
//    delete orders;
   delete P_i;
   delete P_j;
   delete P_l;
   delete Y_nm;
   delete C_m;

 
 
   return iAngMass;

 } 



