/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "MassIntegrator.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "AllMassFunctions.C"
#include "TMath.h" 
#include "Math/SpecFuncMathMore.h"
#include "Math/SpecFunc.h"


ClassImp(MassIntegrator) 




 MassIntegrator::MassIntegrator(const char *name, const char *title, 
                        RooAbsReal& _indx,
                        RooAbsReal& _m1,
                        RooAbsReal& _m2,
			   RooAbsReal& _fL,
			   RooAbsReal& _fpa,
			   RooAbsReal& _Asp2,
			   RooAbsReal& _Asm2,
			   RooAbsReal& _Ass2,
			   RooAbsReal& _dpa,
			   RooAbsReal& _dpe,
			   RooAbsReal& _dsp,
			   RooAbsReal& _dsm,
			   RooAbsReal& _dss,
                        RooAbsReal& _Gs,
                        RooAbsReal& _DGs,
                        RooAbsReal& _m_kst,
                        RooAbsReal& _m_kst0,
                        RooAbsReal& _g_kst,
                        RooAbsReal& _g_kst0,
                        RooAbsReal& _m_Bs,
			   RooAbsReal& _norm,
			   RooAbsReal& _normP,
			   RooAbsReal& _normS,
			   RooAbsReal& _normSS,
		 RooAbsReal& _leg_n_m1,
		 RooAbsReal& _leg_n_m2) :
   RooAbsReal(name,title), 
   indx("indx","indx",this,_indx),
   m1("m1","m1",this,_m1),
   m2("m2","m2",this,_m2),
    fL("fL","fL",this,_fL),
    fpa("fpa","fpa",this,_fpa),
    Asp2("Asp2","Asp2",this,_Asp2),
    Asm2("Asm2","Asm2",this,_Asm2),
    Ass2("Ass2","Ass2",this,_Ass2),
    dpa("dpa","dpa",this,_dpa),
    dpe("dpe","dpe",this,_dpe),
    dsp("dsp","dsp",this,_dsp),
    dsm("dsm","dsm",this,_dsm),
    dss("dss","dss",this,_dss),
    m_kst("m_kst","m_kst",this,_m_kst),
    m_kst0("m_kst0","m_kst0",this,_m_kst0),
    g_kst("g_kst","g_kst",this,_g_kst),
    g_kst0("g_kst0","g_kst0",this,_g_kst0),
    m_Bs("m_Bs","m_Bs",this,_m_Bs),
    Gs("Gs","Gs",this,_Gs),
    DGs("DGs","DGs",this,_DGs),
    norm("norm","norm",this,_norm),
    normP("normP","normP",this,_normP),
    normS("normS","normS",this,_normS),
   normSS("normSS","normSS",this,_normSS),
   leg_n_m1("leg_n_m1","leg_n_m1",this,_leg_n_m1),
   leg_n_m2("leg_n_m2","leg_n_m2",this,_leg_n_m2)
 { 
 } 


 MassIntegrator::MassIntegrator(const MassIntegrator& other, const char* name) :  
   RooAbsReal(other,name), 
   indx("indx",this,other.indx),
   m1("m1",this,other.m1),
   m2("m2",this,other.m2),
  fL("fL",this,other.fL),
  fpa("fpa",this,other.fpa),
  Asp2("Asp2",this,other.Asp2),
  Asm2("Asm2",this,other.Asm2),
  Ass2("Ass2",this,other.Ass2),
  dpa("dpa",this,other.dpa),
  dpe("dpe",this,other.dpe),
  dsp("dsp",this,other.dsp),
  dsm("dsm",this,other.dsm),
  dss("dss",this,other.dss),
  m_kst("m_kst",this,other.m_kst),
  m_kst0("m_kst0",this,other.m_kst0),
  g_kst("g_kst",this,other.g_kst),
  g_kst0("g_kst0",this,other.g_kst0),
  m_Bs("m_Bs",this,other.m_Bs),
  Gs("Gs",this,other.Gs),
  DGs("DGs",this,other.DGs),
  norm("norm",this,other.norm),
  normP("normP",this,other.normP),
  normS("normS",this,other.normS),
   normSS("normSS",this,other.normSS),
   leg_n_m1("leg_n_m1",this,other.leg_n_m1),
   leg_n_m2("leg_n_m2",this,other.leg_n_m2)
 { 
 } 



 Double_t MassIntegrator::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
  double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);

  double leg_m1 = ROOT::Math::legendre(leg_n_m1,m1_red);
  double leg_m2 = ROOT::Math::legendre(leg_n_m2,m2_red);


  Double_t massterm = get_MassTerm(indx,  m1,  m2,
				   fL,  fpa,  Asp2,  Asm2,  Ass2,
				   dpa,  dpe,  dsp,  dsm,  dss,
				   Gs,  DGs,
				   m_kst,  m_kst0,
				   g_kst,  g_kst0 ,
				   m_Bs,  normP,  normS,  normSS);
  



  return massterm*leg_m1*leg_m2; 
 } 



//  Int_t MassIntegrator::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
//  { 
//    // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
//    // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
//    // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
//    // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
//    // EXPRESSION MULTIPLE TIMES

//    // if (matchArgs(allVars,analVars,x)) return 1 ; 
//    return 0 ; 
//  } 



//  Double_t MassIntegrator::analyticalIntegral(Int_t code, const char* rangeName) const  
//  { 
//    // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
//    // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
//    // BOUNDARIES FOR EACH OBSERVABLE x

//    // assert(code==1) ; 
//    // return (x.max(rangeName)-x.min(rangeName)) ; 
//    return 0 ; 
//  } 



