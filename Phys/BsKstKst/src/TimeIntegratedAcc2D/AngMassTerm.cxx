/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "AngMassTerm.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "Math/SpecFuncMathMore.h"
#include "Math/SpecFunc.h"

#include <AllAngFunctions.C>
#include <AllMassFunctions.C>
#include <AllAmplitudes.C>

#include "RooArgList.h"
#include "TTree.h"
#include "TF1.h"
#include "TFile.h"

using namespace std;



ClassImp(AngMassTerm) 

 AngMassTerm::AngMassTerm(const char *name, const char *title, 
			Int_t _indx,
		        RooAbsReal& _c1,
                        RooAbsReal& _c2,
                        RooAbsReal& _ph,
                        RooAbsReal& _m1,
                        RooAbsReal& _m2,
                        RooAbsReal& _fL,
                        RooAbsReal& _fpa,
                        RooAbsReal& _Asp2,
                        RooAbsReal& _Asm2,
                        RooAbsReal& _Ass2,
                        RooAbsReal& _dpa,
                        RooAbsReal& _dpe,
                        RooAbsReal& _dsp,
                        RooAbsReal& _dsm,
                        RooAbsReal& _dss,
                        RooAbsReal& _m_kst,
                        RooAbsReal& _m_kst0,
                        RooAbsReal& _g_kst,
                        RooAbsReal& _g_kst0,
                        RooAbsReal& _m_Bs,
                        RooAbsReal& _Gs,
                        RooAbsReal& _DGs,
                        RooAbsReal& _norm,
                        RooAbsReal& _normP,
                        RooAbsReal& _normS,
			RooAbsReal& _normSS,
			char *_treename,
// 			TTree *tin,
			char *_branchname) :
   RooAbsReal(name,title), 
   c1("c1","c1",this,_c1),
   c2("c2","c2",this,_c2),
   ph("ph","ph",this,_ph),
   m1("m1","m1",this,_m1),
   m2("m2","m2",this,_m2),
   fL("fL","fL",this,_fL),
   fpa("fpa","fpa",this,_fpa),
   Asp2("Asp2","Asp2",this,_Asp2),
   Asm2("Asm2","Asm2",this,_Asm2),
   Ass2("Ass2","Ass2",this,_Ass2),
   dpa("dpa","dpa",this,_dpa),
   dpe("dpe","dpe",this,_dpe),
   dsp("dsp","dsp",this,_dsp),
   dsm("dsm","dsm",this,_dsm),
   dss("dss","dss",this,_dss),
   m_kst("m_kst","m_kst",this,_m_kst),
   m_kst0("m_kst0","m_kst0",this,_m_kst0),
   g_kst("g_kst","g_kst",this,_g_kst),
   g_kst0("g_kst0","g_kst0",this,_g_kst0),
   m_Bs("m_Bs","m_Bs",this,_m_Bs),
   Gs("Gs","Gs",this,_Gs),
   DGs("DGs","DGs",this,_DGs),
   norm("norm","norm",this,_norm),
   normP("normP","normP",this,_normP),
   normS("normS","normS",this,_normS),
   normSS("normSS","normSS",this,_normSS)
 { 

   indx = _indx;
   
   TFile fin(_treename);
   TTree *tin = (TTree*)fin.Get("acc5D");
   tin->SetBranchAddress(_branchname,&acc_coeffs);
   tin->GetEntry(0);
   
   delete tin;
   fin.Close();
   
 }


 


 AngMassTerm::AngMassTerm(const AngMassTerm& other, const char* name) :  
   RooAbsReal(other,name), 
   c1("c1",this,other.c1),
   c2("c2",this,other.c2),
   ph("ph",this,other.ph),
   m1("m1",this,other.m1),
   m2("m2",this,other.m2),
   fL("fL",this,other.fL),
   fpa("fpa",this,other.fpa),
   Asp2("Asp2",this,other.Asp2),
   Asm2("Asm2",this,other.Asm2),
   Ass2("Ass2",this,other.Ass2),
   dpa("dpa",this,other.dpa),
   dpe("dpe",this,other.dpe),
   dsp("dsp",this,other.dsp),
   dsm("dsm",this,other.dsm),
   dss("dss",this,other.dss),
   m_kst("m_kst",this,other.m_kst),
   m_kst0("m_kst0",this,other.m_kst0),
   g_kst("g_kst",this,other.g_kst),
   g_kst0("g_kst0",this,other.g_kst0),
   m_Bs("m_Bs",this,other.m_Bs),
   Gs("Gs",this,other.Gs),
   DGs("DGs",this,other.DGs),
   norm("norm",this,other.norm),
   normP("normP",this,other.normP),
   normS("normS",this,other.normS),
   normSS("normSS",this,other.normSS)
 { 

   indx = other.indx;

   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){

       acc_coeffs[i][j] = other.acc_coeffs[i][j];
       cout<<"acc_coeff_"<<i<<j<<" = "<<acc_coeffs[i][j]<<endl;
     }
   }


 } 


double AngMassTerm::get_Acceptance(double ci, double mi) const 
{

   double P_i1=0; double P_j1=0; 
   double Eff1=0;

   double mi_red = (mi - 746)/(1046 - 746)*2. + (-1);

   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
	     P_i1 = ROOT::Math::legendre(i,mi_red);
	     P_j1 = ROOT::Math::legendre(j,ci);
	     
             Eff1 += acc_coeffs[i][j]*(P_i1*P_j1);
	   }
	 }


   if (Eff1<0) return 0.;
   
//    cout<<"Salgo de aqui..."<<endl;
     return Eff1;
 } 



 Double_t AngMassTerm::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   //Time integrated amplitudes
   Double_t Kindx = get_Amplitude(indx,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,norm);

   // Mass amplitudes
   Double_t Mindx = get_MassTerm(indx,m1,m2,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,m_kst,m_kst0,g_kst,g_kst0,m_Bs,normP,normS,normSS);   

   // Angular Amplitudes
   Double_t findx = get_AngTerm(indx,c1,c2,ph);

   // Products
   Double_t product = Mindx*findx*Kindx;


   Double_t acc1 = get_Acceptance(c1,m1);
   Double_t acc2 = get_Acceptance(c2,m2);


   Double_t val = product*acc1*acc2;

   return val;
 } 



 Int_t AngMassTerm::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 


   // RooArgSet emptyset;
   // RooAbsArg *var;

   // if (matchArgs(allVars,emptyset,c1,c2,ph,m1))
   //   {
   //     if (matchArgs(allVars,analVars,m2)){
	
   // 	 TIterator* iter_empty = emptyset.createIterator();
   // 	 while((var = (RooAbsArg*)iter_empty->Next())) {

   // 	   analVars.add(*var);
   // 	 }
       
   // 	 return 1 ;
   //     }
   //   }
//    if (matchArgs(allVars,analVars,c1,c2,ph,m1   )) return 2 ;
//    if (matchArgs(allVars,analVars,c1,c2,ph   ,m2)) return 3 ;
//    if (matchArgs(allVars,analVars,c1,c2,   m1,m2)) return 4 ;
//    if (matchArgs(allVars,analVars,c1,   ph,m1,m2)) return 5 ;
//    if (matchArgs(allVars,analVars,   c2,ph,m1,m2)) return 6 ;
   
   if (matchArgs(allVars,analVars,c1,c2,ph)) return 7 ;
//    if (matchArgs(allVars,analVars,c1,c2,m1)) return 8 ;
//    if (matchArgs(allVars,analVars,c1,c2,m2)) return 9 ;
//    if (matchArgs(allVars,analVars,c1,ph,m1)) return 10 ;
//    if (matchArgs(allVars,analVars,c1,ph,m2)) return 11 ;
//    if (matchArgs(allVars,analVars,c1,m1,m2)) return 12 ;
//    if (matchArgs(allVars,analVars,c2,ph,m1)) return 13 ;
//    if (matchArgs(allVars,analVars,c2,ph,m2)) return 14 ;
//    if (matchArgs(allVars,analVars,c2,m1,m2)) return 15 ;
//    if (matchArgs(allVars,analVars,ph,m1,m2)) return 16 ;

   if (matchArgs(allVars,analVars,c1,c2)) return 17 ;
   if (matchArgs(allVars,analVars,c1,ph)) return 18 ;
//    if (matchArgs(allVars,analVars,c1,m1)) return 19 ;
//    if (matchArgs(allVars,analVars,c1,m2)) return 20 ;
   if (matchArgs(allVars,analVars,c2,ph)) return 21 ;
//    if (matchArgs(allVars,analVars,c2,m1)) return 22 ;
//    if (matchArgs(allVars,analVars,c2,m2)) return 23 ;
//    if (matchArgs(allVars,analVars,ph,m1)) return 24 ;
//    if (matchArgs(allVars,analVars,ph,m2)) return 25 ;
//    if (matchArgs(allVars,analVars,m1,m2)) return 26 ;

   if (matchArgs(allVars,analVars,c1)) return 27 ;
   if (matchArgs(allVars,analVars,c2)) return 28 ;
   if (matchArgs(allVars,analVars,ph)) return 29 ;
//    if (matchArgs(allVars,analVars,m1)) return 30 ;
//    if (matchArgs(allVars,analVars,m2)) return 31 ;



   return 0 ; 
 } 



 Double_t AngMassTerm::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 


   //Time integrated amplitudes
   Double_t Kindx = get_Amplitude(indx,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,norm);

   // Mass amplitudes
   Double_t Mindx = get_MassTerm(indx,m1,m2,fL,fpa,Asp2,Asm2,Ass2,dpa,dpe,dsp,dsm,dss,Gs,DGs,m_kst,m_kst0,g_kst,g_kst0,m_Bs,normP,normS,normSS);   

   // Angular Amplitudes
   Double_t conindx = get_AngTerm_Coefficient(indx);
   Double_t fc1indx = get_AngTerm_CosTheta1(indx,c1);
   Double_t fc2indx = get_AngTerm_CosTheta2(indx,c2);
   Double_t fphindx = get_AngTerm_Phi(indx,ph);


   double fangmass1[MYA][MYB];
   double fangmass2[MYA][MYB];
   
   double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
   double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);

//    TF1 *P_i = new TF1("P_i","ROOT::Math::legendre([0],x)",-1,1);
//    TF1 *P_j = new TF1("P_j","ROOT::Math::legendre([0],x)",-1,1);
   
   double IPi1,IPi2;
   double IPj1,IPj2;

   for (int i_=0; i_<MYA; i_++)
     {
       for (int j_=0; j_<MYB; j_++)
	 {
// 	   P_i->SetParameter(0,i_);
// 	   P_j->SetParameter(0,j_);
	   
	   IPi1 = ROOT::Math::legendre(i_,m1_red);
	   IPi2 = ROOT::Math::legendre(i_,m2_red);
	   IPj1 = ROOT::Math::legendre(j_,c1);
	   IPj2 = ROOT::Math::legendre(j_,c2);
       
	   fangmass1[i_][j_] = IPi1*IPj1*fc1indx;
	   fangmass2[i_][j_] = IPi2*IPj2*fc2indx;
	 }
     }



   if (code==7 || code==17 || code==18 || code==27)
     {
       //Integral in the interval [-1,1]
       for (int i_=0; i_<MYA; i_++)
	 {
	   for (int j_=0; j_<MYB; j_++)
	     {
// 	       P_i->SetParameter(0,i_);
	       IPi1 = ROOT::Math::legendre(i_,m1_red);

	       IPj1 = get_CosTheta1_Integral(indx,j_);
       
	       fangmass1[i_][j_] = IPi1*IPj1;
	     }
	 }
     }
     
   if (code==7 || code==17 || code==21 || code==28)
     {
       //Integral in the interval [-1,1]
       for (int i_=0; i_<MYA; i_++)
	 {
	   for (int j_=0; j_<MYB; j_++)
	     {
// 	       P_i->SetParameter(0,i_);
	       IPi2 = ROOT::Math::legendre(i_,m2_red);
	       
	       IPj2 = get_CosTheta2_Integral(indx,j_);
	       
	       fangmass2[i_][j_] = IPi2*IPj2;
	     }
	 }
     }

   if (code==7 || code==18 || code==21 || code==29) 
     {
       Double_t phmin = ph.min(rangeName);
       Double_t phmax = ph.max(rangeName);
       fphindx = get_Phi_Integral(indx,phmin,phmax);
     }


   Double_t iAngMass1=0;
   Double_t iAngMass2=0;
   
   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){

       iAngMass1+= acc_coeffs[i][j]*fangmass1[i][j];
       iAngMass2+= acc_coeffs[i][j]*fangmass2[i][j];
     }
   }



//    delete P_i;
//    delete P_j;

 
 
   return conindx*Kindx*iAngMass1*iAngMass2*Mindx*fphindx;

 } 



