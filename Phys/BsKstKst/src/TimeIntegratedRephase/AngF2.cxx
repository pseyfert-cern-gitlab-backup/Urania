/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "AngF2.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(AngF2) 

 Double_t AngF2::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   Double_t c1_2 = c1*c1;
   Double_t c2_2 = c2*c2;
   Double_t s1_2 = 1.-c1_2;
   Double_t s2_2 = 1.-c2_2;

   Double_t coefsTH[5];
   Double_t coefsPH[5];

   getAccTHCoefs(coefsTH);
   getAccPHCoefs(coefsPH);

   Double_t c1_th = coefsTH[0];
   Double_t c2_th = coefsTH[1];
   Double_t c3_th = coefsTH[2];
   Double_t c4_th = coefsTH[3];
   Double_t c5_th = coefsTH[4];

   Double_t c1_ph = coefsPH[0];
   Double_t c2_ph = coefsPH[1];
   Double_t c3_ph = coefsPH[2];

   Double_t acc_th1 = 1. + c1_th*c1 + c2_th*c1_2 + c3_th*c1_2*c1 + c4_th*c1_2*c1_2 + c5_th*c1_2*c1_2*c1;
   Double_t acc_th2 = 1. + c1_th*c2 + c2_th*c2_2 + c3_th*c2_2*c2 + c4_th*c2_2*c2_2 + c5_th*c2_2*c2_2*c2;
   Double_t acc_phi = 1. + c1_ph*cos( c2_ph*ph + c3_ph);

   Double_t acc_val = acc_th1*acc_th2*acc_phi;

   if (acc_val<0){
     return 0.0000100001;
   }

   return  s1_2*s2_2*(1+cos(2*ph))*acc_val; 
 } 



Double_t AngF2::analyticalIntegral(Int_t code, const char* rangeName) const
{
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 
 
   Double_t coefsTH[5];
   Double_t coefsPH[5];

   getAccTHCoefs(coefsTH);
   getAccPHCoefs(coefsPH);

   Double_t c1_th = coefsTH[0];
   Double_t c2_th = coefsTH[1];
   Double_t c3_th = coefsTH[2];
   Double_t c4_th = coefsTH[3];
   Double_t c5_th = coefsTH[4];

   Double_t c1_ph = coefsPH[0];
   Double_t c2_ph = coefsPH[1];
   Double_t c3_ph = coefsPH[2];


   double ic1;
   if (code==1 || code==2 || code==3 || code==5){

     Double_t hic1 = c1.max(rangeName);
     Double_t loc1 = c1.min(rangeName);

     double x1 = hic1 + c1_th*pow(hic1,2)/2. - (1-c2_th)*pow(hic1,3)/3. - (c1_th-c3_th)*pow(hic1,4)/4. - (c2_th-c4_th)*pow(hic1,5)/5. - (c3_th-c5_th)*pow(hic1,6)/6. - c4_th*pow(hic1,7)/7. - c5_th*pow(hic1,8)/8.;
     double y1 = loc1 + c1_th*pow(loc1,2)/2. - (1-c2_th)*pow(loc1,3)/3. - (c1_th-c3_th)*pow(loc1,4)/4. - (c2_th-c4_th)*pow(loc1,5)/5. - (c3_th-c5_th)*pow(loc1,6)/6. - c4_th*pow(loc1,7)/7. - c5_th*pow(loc1,8)/8.;

     ic1 = x1-y1;

   }else {
     Double_t c1_2 = c1*c1;
     Double_t acc_th1 = 1. + c1_th*c1 + c2_th*c1_2 + c3_th*c1_2*c1 + c4_th*c1_2*c1_2 + c5_th*c1_2*c1_2*c1;

     ic1 = (1-c1*c1)*acc_th1;
   }


   double ic2;
   if (code==1 || code==2 || code==4 || code==6){

     Double_t hic2 = c2.max(rangeName);
     Double_t loc2 = c2.min(rangeName);

     double x2 = hic2 + c1_th*pow(hic2,2)/2. - (1-c2_th)*pow(hic2,3)/3. - (c1_th-c3_th)*pow(hic2,4)/4. - (c2_th-c4_th)*pow(hic2,5)/5. - (c3_th-c5_th)*pow(hic2,6)/6. - c4_th*pow(hic2,7)/7. - c5_th*pow(hic2,8)/8.;
     double y2 = loc2 + c1_th*pow(loc2,2)/2. - (1-c2_th)*pow(loc2,3)/3. - (c1_th-c3_th)*pow(loc2,4)/4. - (c2_th-c4_th)*pow(loc2,5)/5. - (c3_th-c5_th)*pow(loc2,6)/6. - c4_th*pow(loc2,7)/7. - c5_th*pow(loc2,8)/8.;

     ic2 = x2-y2;
     
   }else{
     Double_t c2_2 = c2*c2;
     Double_t acc_th2 = 1. + c1_th*c2 + c2_th*c2_2 + c3_th*c2_2*c2 + c4_th*c2_2*c2_2 + c5_th*c2_2*c2_2*c2;
   
     ic2 = (1-c2*c2)*acc_th2;
   }


   double iph;
   if (code==1 || code==3 || code==4 || code==7 ){

     Double_t hiph = ph.max(rangeName);
     Double_t loph = ph.min(rangeName);

     double x3 = hiph + sin(2*hiph)/2. + c1_ph*( cos(c2_ph*hiph)*sin(c3_ph)/c2_ph + cos(c3_ph)*sin(c2_ph*hiph)/c2_ph ) + c1_ph*sin(c3_ph + (c2_ph-2.)*hiph)/(2*(c2_ph-2.)) + c1_ph*sin(c3_ph + (c2_ph+2.)*hiph)/(2*(c2_ph+2.));
     double y3 = loph + sin(2*loph)/2. + c1_ph*( cos(c2_ph*loph)*sin(c3_ph)/c2_ph + cos(c3_ph)*sin(c2_ph*loph)/c2_ph ) + c1_ph*sin(c3_ph + (c2_ph-2.)*loph)/(2*(c2_ph-2.)) + c1_ph*sin(c3_ph + (c2_ph+2.)*loph)/(2*(c2_ph+2.));


     iph = x3-y3;
   }else{
     Double_t acc_ph = 1. + c1_ph*cos( c2_ph*ph + c3_ph);

     iph = (1+cos(2*ph))*acc_ph;
   }


   return ic1*ic2*iph;


} 



