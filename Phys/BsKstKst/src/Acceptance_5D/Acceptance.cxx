/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "Acceptance.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TFile.h"
#include "TMath.h" 
#include "Math/SpecFuncMathMore.h"
#include "TTree.h"
#include "TF1.h"
//#include <gsl/gsl_sf_legendre.h>


ClassImp(Acceptance) 

//  template<int i, int j, int l, int n, int m>  Acceptance::Acceptance(const char *name, const char *title, 
//                         RooAbsReal& _c1,
//                         RooAbsReal& _c2,
//                         RooAbsReal& _ph,
//                         RooAbsReal& _m1,
//                         RooAbsReal& _m2,
// 			Int_t *_orders,
// 								     double (&_coeffs)[i][j][l])://double _coeffs[][][]);
//    RooAbsReal(name,title), 
//    c1("c1","c1",this,_c1),
//    c2("c2","c2",this,_c2),
//    ph("ph","ph",this,_ph),
//    m1("m1","m1",this,_m1),
//    m2("m2","m2",this,_m2)
//  {

//    int dimension = 3;
   

//    for(int r=0;r<dimension; r++){
//      orders[r] = (Int_t)_orders[r];
//    }


//    for (int a=0;a<orders[0];a++){
//      for (int b=0;b<orders[1];b++){
//         for (int c=0;c<orders[2];c++){

// 	     coeffs[a][b][c] = _coeffs[a][b][c];
// 	}}}
 
//  }

 Acceptance::Acceptance(const char *name, const char *title, 
                        RooAbsReal& _c1,
                        RooAbsReal& _c2,
                        RooAbsReal& _ph,
                        RooAbsReal& _m1,
                        RooAbsReal& _m2,
// 			Int_t _dimension,
			TTree *tin,//) :
// 			char *_filename,
// 			char *_treename,
			char *_branchname) :
// 			Double_t (&_coeffs)[3][3][5][5][3]) :
   RooAbsReal(name,title), 
   c1("c1","c1",this,_c1),
   c2("c2","c2",this,_c2),
   ph("ph","ph",this,_ph),
   m1("m1","m1",this,_m1),
   m2("m2","m2",this,_m2)
 { 
   
   //cout<<"Empiezo"<<endl;
//    dimension = _dimension;
//    TFile fin(_filename);
//    TTree *tree = (TTree*)fin.Get(_treename);
   tin->SetBranchAddress(_branchname,&coeffs);
   tin->GetEntry(0);
//    fin.Close();
//    coeffTree = tin->CopyTree("1");

//    coeffTree->SetBranchAddress("coeffs",&coeffs);
//    //cout<<"Llamo a la entrada 0"<<endl;
//    coeffTree->GetEntry(0);



   //cout<<"Orders..."<<endl;
//    for(int r=0;r<MYDIM; r++){
//      //cout<< "Que es orders..."<< _orders << endl;
//      orders[r] = _orders[r];
//    }

   //cout<<"Defino coeffs volatiles..."<<endl;
//    double _coeffs[3][3][5][5][3];
   //const char _branchname = "coeffs";
//    //cout<<"Abro el fichero"<<endl;
//    TFile fin(_filename);
//    //cout<<"Accedo al tree"<<endl;
//    TTree *tin = (TTree*)fin.Get(_treename);
//    //cout<<"Defino la branch"<<endl;
//    tin->SetBranchAddress("coeffs",&_coeffs);
//    //cout<<"Llamo a la entrada 0"<<endl;
//    tin->GetEntry(0);

//    //cout<<"For loop para asignar los coeffs"<<endl;
//    for (Int_t i=0;i<orders[0];i++){
//      for (Int_t j=0;j<orders[1];j++){
//        for (Int_t l=0;l<orders[2];l++){
// 	 for (Int_t n=0;n<orders[3];n++){
// 	   for (Int_t m=0;m<orders[4];m++){

	     
// 	     coeffs[i][j][l][n][m] = (Double_t) _coeffs[i][j][l][n][m];
// 	     cout <<"C_"<<i<<j<<l<<n<<m<<" = "<<coeffs[i][j][l][n][m]<<endl;

// 	   }
// 	 }
//        }
//      }
//    }
//    fin.Close();
   //cout<<"Me voy del constructor!!"<<endl;
 } 


 Acceptance::Acceptance(const Acceptance& other, const char* name) :  
   RooAbsReal(other,name), 
   c1("c1",this,other.c1),
   c2("c2",this,other.c2),
   ph("ph",this,other.ph),
   m1("m1",this,other.m1),
   m2("m2",this,other.m2)
 { 

//    cout<<"El problema esta aqui?"<<endl;

//    dimension = other.dimension;
//    coeffs = other.coeffs;
   
//    coeffTree = other.coeffTree->CopyTree("1");
//    coeffTree->SetBranchAddress("coeffs",coeffs);
//    //cout<<"Llamo a la entrada 0"<<endl;
//    coeffTree->GetEntry(0);

//    for(int r=0;r<dimension; r++){
//      orders[r] = other.orders[r];
//    }


   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
	 for (Int_t n=0;n<orders[3];n++){
	   for (Int_t m=0;m<orders[4];m++){

	     coeffs[i][j][l][n][m] = other.coeffs[i][j][l][n][m];
	     cout <<"C_"<<i<<j<<l<<n<<m<<" = "<< coeffs[i][j][l][n][m] << endl;


	   }
	 }
       }
     }
   }
   
//    cout<<"No... esta en otro lado"<<endl;
 } 


// Int_t Acceptance::getCoeffs(void *coeffs_) const
// {

// //    double _coeffs[3][3][5][5][3];

//    coeffTree->SetBranchAddress("coeffs",coeffs_);
//    //cout<<"Llamo a la entrada 0"<<endl;
//    coeffTree->GetEntry(0);
   
//    return 1;

// //    Int_t orders[5];
// //    orders[0] = 3; orders[1] = 3; orders[2] = 5; orders[3] = 5; orders[4] =3;

// //    //cout<<"For loop para asignar los coeffs"<<endl;
// //    for (Int_t i=0;i<orders[0];i++){
// //      for (Int_t j=0;j<orders[1];j++){
// //        for (Int_t l=0;l<orders[2];l++){
// // 	 for (Int_t n=0;n<orders[3];n++){
// // 	   for (Int_t m=0;m<orders[4];m++){

	     
// // 	     coeffs[i][j][l][n][m] = (Double_t) _coeffs[i][j][l][n][m];
// // 	     cout <<"C_"<<i<<j<<l<<n<<m<<" = "<<coeffs[i][j][l][n][m]<<endl;

// // 	   }
// // 	 }
// //        }
// //      }
// //    }

// }

 Double_t Acceptance::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

//    cout<<"Entro aqui..."<<endl;

   double Y_nm=0; double P_i=0; double P_j=0; double P_l=0;
   double Eff=0;

   double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
   double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);

   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
	 for (Int_t n=0;n<orders[3];n++){
	   for (Int_t m=0;m<orders[4];m++){
	     P_i  = ROOT::Math::legendre(i,m1_red);//gsl_sf_legendre_Pl(i,m1_red);                                                                              
	     //cout<< "P_j" << endl;
	     P_j  = ROOT::Math::legendre(j,m2_red);//gsl_sf_legendre_Pl(j,m2_red);                                                                              
	     //cout<< "P_l" << endl;
	     P_l  = ROOT::Math::legendre(l,c1);//gsl_sf_legendre_Pl(l,c1);
	     //cout<< "Y_nm" << endl;
	     if ( m>n ) continue;
	     else if ( m == 0 )	 Y_nm = ROOT::Math::sph_legendre(n,m,acos(c2));
	     else          Y_nm = sqrt(2) * ROOT::Math::sph_legendre(n,m,acos(c2)) * cos(m*ph);//sqrt(2) * gsl_sf_legendre_sphPlm(n,m,c2) * cos(m*ph);

// 	    cout <<"C_"<<i<<j<<l<<n<<m<<" = "<< coeffs[i][j][l][n][m] << endl;

             Eff += coeffs[i][j][l][n][m]*(P_i*P_j*P_l* Y_nm);
	   }
	 }
       }
     }
   }

//    cout<<"Salgo de aqui..."<<endl;
     return Eff;
 } 

 Int_t Acceptance::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
 {
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,  
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS   
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X      
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs   
   // EXPRESSION MULTIPLE TIMES       

   // if (matchArgs(allVars,analVars,x)) return 1 ; 

   if (matchArgs(allVars,analVars,c1,c2,ph,m1))
     {
       if (matchArgs(allVars,analVars,m2)) return 1 ;
     }
   if (matchArgs(allVars,analVars,c1,c2,ph,m1   )) return 2 ;
   if (matchArgs(allVars,analVars,c1,c2,ph   ,m2)) return 3 ;
   if (matchArgs(allVars,analVars,c1,c2,   m1,m2)) return 4 ;
   if (matchArgs(allVars,analVars,c1,   ph,m1,m2)) return 5 ;
   if (matchArgs(allVars,analVars,   c2,ph,m1,m2)) return 6 ;
   
   if (matchArgs(allVars,analVars,c1,c2,ph)) return 7 ;
   if (matchArgs(allVars,analVars,c1,c2,m1)) return 8 ;
   if (matchArgs(allVars,analVars,c1,c2,m2)) return 9 ;
   if (matchArgs(allVars,analVars,c1,ph,m1)) return 10 ;
   if (matchArgs(allVars,analVars,c1,ph,m2)) return 11 ;
   if (matchArgs(allVars,analVars,c1,m1,m2)) return 12 ;
   if (matchArgs(allVars,analVars,c2,ph,m1)) return 13 ;
   if (matchArgs(allVars,analVars,c2,ph,m2)) return 14 ;
   if (matchArgs(allVars,analVars,c2,m1,m2)) return 15 ;
   if (matchArgs(allVars,analVars,ph,m1,m2)) return 16 ;

   if (matchArgs(allVars,analVars,c1,c2)) return 17 ;
   if (matchArgs(allVars,analVars,c1,ph)) return 18 ;
   if (matchArgs(allVars,analVars,c1,m1)) return 19 ;
   if (matchArgs(allVars,analVars,c1,m2)) return 20 ;
   if (matchArgs(allVars,analVars,c2,ph)) return 21 ;
   if (matchArgs(allVars,analVars,c2,m1)) return 22 ;
   if (matchArgs(allVars,analVars,c2,m2)) return 23 ;
   if (matchArgs(allVars,analVars,ph,m1)) return 24 ;
   if (matchArgs(allVars,analVars,ph,m2)) return 25 ;
   if (matchArgs(allVars,analVars,m1,m2)) return 26 ;

   if (matchArgs(allVars,analVars,c1)) return 27 ;
   if (matchArgs(allVars,analVars,c2)) return 28 ;
   if (matchArgs(allVars,analVars,ph)) return 29 ;
   if (matchArgs(allVars,analVars,m1)) return 30 ;
   if (matchArgs(allVars,analVars,m2)) return 31 ;

   return 0 ;
 }


Double_t Acceptance::analyticalIntegral(Int_t code, const char* rangeName) const
{

   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral 
   // THE MEMBER FUNCTION x.min(binRange) AND x.max(binRange) WILL RETURN THE INTEGRATION1   
   // BOUNDARIES FOR EACH OBSERVABLE x      

   // assert(code==1) ;
   // return (x.max(binRange)-x.min(binRange)) ;

   double m1_red = (m1 - 746)/(1046 - 746)*2. + (-1);
   double m2_red = (m2 - 746)/(1046 - 746)*2. + (-1);

   double iY_nm[MYD][MYF];
   double iY_m[MYF];
   double iP_i[MYA];
   double iP_j[MYB];
   double iP_l[MYC];

   TF1 *P_i = new TF1("P_i","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *P_j = new TF1("P_j","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *P_l = new TF1("P_l","ROOT::Math::legendre([0],x)",-1,1);
   TF1 *Y_nm = new TF1("Y_nm","ROOT::Math::sph_legendre([0],[1],acos(x))",-1,1);
   TF1 *C_m = new TF1("P_m","cos([0]*x)",0.,2*TMath::Pi());
 
   for (int i_=0; i_<MYA; i_++)
     {
       P_i->SetParameter(0,i_);
       iP_i[i_]=P_i->Eval(m1_red);
     }
   for (int j_=0; j_<MYB; j_++)
     {
       P_j->SetParameter(0,j_);
       iP_j[j_]=P_j->Eval(m2_red);
     }
   for (int l_=0; l_<MYC; l_++)
     {
       P_l->SetParameter(0,l_);
       iP_l[l_]=P_l->Eval(c1);
     }
   for (int n_=0; n_<MYD; n_++)
     {
       for (int m_=0; m_<MYF; m_++)
	 {
	   if(m_>n_) continue;
	   Y_nm->SetParameter(0,n_);
	   Y_nm->SetParameter(1,m_);
	   iY_nm[n_][m_]=Y_nm->Eval(c2);
	   if (m_==0) iY_m[m_]=1;
	   else{
	     C_m->SetParameter(0,m_);
	     iY_m[m_]=sqrt(2)*(C_m->Eval(ph));
	   }
	 }}


  
   if ((code>=1 && code<=5) || (code>=7 && code<=12) || (code>=17 && code<=20) || code==27) 
     {
       //Integrate c1
       Double_t c1min = c1.min(rangeName);
       Double_t c1max = c1.max(rangeName);
       for (int ll=0; ll<MYC; ll++)
	 {
	   P_l->SetParameter(0,ll);
	   iP_l[ll] = P_l->Integral(c1min,c1max);
	 }
    
     }
   if ( (code>=1 && code<=4) || (code>=6 && code<=9) || (code>=13 && code<=15) || code==17 || (code>=21 && code<=23) || code==28)
     {
       //Integrate c2
       Double_t c2min = c2.min(rangeName);
       Double_t c2max = c2.max(rangeName);
       for (int nn=0; nn<MYD; nn++)
	 {
	   for (int mm=0; mm<MYF; mm++)
	     {
	       if(mm>nn) continue;
	       Y_nm->SetParameter(0,nn);
	       Y_nm->SetParameter(1,mm);
	       iY_nm[nn][mm]=Y_nm->Integral(c2min,c2max);
	     }}
     }
   if( (code>=1 && code<=3) || (code>=5 && code<=7) || code==10 || code==11 || code==13 || code==14 || code==16 || code==18 || code==21 || code== 24 || code==25 || code==29)
     {
       //Integrate ph
       Double_t phmin = ph.min(rangeName);
       Double_t phmax = ph.max(rangeName);
       for (int mmm=0; mmm<MYF; mmm++)
	 {
	   if (mmm==0) iY_m[mmm]=phmax-phmin;
	   else{
	     C_m->SetParameter(0,mmm);
	     iY_m[mmm] = sqrt(2)*(C_m->Integral(phmin,phmax));
	   }
	 }
     }
   if(code==1 || code==2 || (code>=4 && code<=6) || code==8 || code==10 || code==12 || code==13 || code==15 || code==16 || code==19 || code==22 || code==24 || code==26 || code==30)
     {
       //Integrate m1
       Double_t m1min = m1.min(rangeName);
       Double_t m1max = m1.max(rangeName);
       Double_t m1min_red = (m1min - 746)/(1046 - 746)*2. + (-1);
       Double_t m1max_red = (m1max - 746)/(1046 - 746)*2. + (-1);
       for (int ii=0; ii<MYA; ii++)
	 {
	   P_i->SetParameter(0,ii);
	   iP_i[ii] = P_i->Integral(m1min_red,m1max_red);
	 }
     }
   if(code==1 || (code>=3 && code<=6) || code==9 || code==11 || code==12 || (code>=14 && code<=16) || code==20 || code==23 || code==25 || code==26 || code==31)
     {
       //Integrate m2
       Double_t m2min = m2.min(rangeName);
       Double_t m2max = m2.max(rangeName);
       Double_t m2min_red = (m2min - 746)/(1046 - 746)*2. + (-1);
       Double_t m2max_red = (m2max - 746)/(1046 - 746)*2. + (-1);
       for (int jj=0; jj<MYB; jj++)
	 {
	   P_j->SetParameter(0,jj);
	   iP_j[jj] = P_j->Integral(m2min_red,m2max_red);
	 }
     }


   Double_t iEff=0;
   
   Int_t orders[MYDIM];
   orders[0] = MYA; orders[1] = MYB; orders[2] = MYC; orders[3] = MYD; orders[4] =MYF;
   for (Int_t i=0;i<orders[0];i++){
     for (Int_t j=0;j<orders[1];j++){
       for (Int_t l=0;l<orders[2];l++){
	 for (Int_t n=0;n<orders[3];n++){
	   for (Int_t m=0;m<orders[4];m++){

	     if (m>n) continue;
	     
	     iEff+= coeffs[i][j][l][n][m]*(iP_i[i]*iP_j[j]*iP_l[l]*iY_nm[n][m]*iY_m[m]);
	   }
	 }
       }
     }
   }

   delete P_i; 
   delete P_j; 
   delete P_l; 
   delete Y_nm; 
   delete C_m; 

   return iEff;

}
 
