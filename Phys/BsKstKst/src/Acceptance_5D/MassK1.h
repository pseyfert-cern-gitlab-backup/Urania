/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
  * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#ifndef MASSK1
#define MASSK1

#include "RooAbsReal.h"
#include "RooRealProxy.h"
#include "RooListProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooArgList.h"
#include "RooAbsCategory.h"
#include "TComplex.h"

#include <math.h> 
#include <complex>
using namespace std;


Double_t j = 1;
Double_t mDa = 493.677000; 
Double_t mDb = 139.570180;
Double_t l = 0;
 
class MassK1 : public RooAbsReal {
public:
  MassK1() {} ; 
  MassK1(const char *name, const char *title,
	      RooAbsReal& _m1,
	      RooAbsReal& _m2,
	      RooAbsReal& _m_kst,
	      RooAbsReal& _m_kst0,
	      RooAbsReal& _g_kst,
	      RooAbsReal& _g_kst0,
	 RooAbsReal& _m_Bs,
	 RooArgList& _acc_coefList,
	 RooAbsReal& _norm);

  MassK1(const MassK1& other, const char* name=0);


  virtual TObject* clone(const char* newname) const { return new MassK1(*this,newname); }
  inline virtual ~MassK1() { }

  Double_t calculatePDF_1D (Int_t indx) const;//(Double_t m_kst, Double_t m_kstb) const;
  Double_t getPDF_1D (Double_t m_kst, Double_t m_kstb) const;//(Double_t m_kst, Double_t m_kstb) const;
  Double_t getPDF_2D (Double_t mkst, Double_t mkstb) const;//(Double_t m_kst, Double_t m_kstb) const;
  
  Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=0) const ;
  Double_t analyticalIntegral(Int_t code, const char* rangeName=0) const ;

                                                                                               

  Double_t evaluate() const ;


  Double_t get_q( Double_t Mass, Double_t m1_, Double_t m2_)const;


  Double_t Blatt_Weisskopf(Double_t Q_, Double_t Q0_, Int_t L_ = 1)const
  {
  if (L_<1.) return 1.;
  
  Double_t d_ = 3.e-03/L_;/// this is true for L_ = 1,2. No clue for the rest!!!!!.
  Double_t z_ = Q_*d_*Q_*d_;
  Double_t z0_ = Q0_*d_*Q0_*d_;
  if (L_==1) return (1+z0_)/(1+z_);
  if (L_==2) return ((z0_-3)*(z0_-3) + 9*z0_) / ((z_-3)*(z_-3) + 9*z_);
  if (L_==3) return (z0_*(z0_-15)*(z0_-15) + 9*(z0_-5)) / (z_*(z_-15)*(z_-15) + 9*(z_-5));
  return ( pow(z0_*z0_ -45*z0_+105,2) +25*z0_*(2*z0_-21)*(2*z0_-21)) /(pow(z_*z_ -45*z_+105,2) +25*z_*(2*z_-21)*(2*z_-21));
  }

  Double_t Blatt_Weisskopf_fM(Double_t M, Int_t L_ = 1, Double_t m1_=139.57018,Double_t m2_=493.677,Double_t M0=895.94)const
  {
    Double_t q = get_q(M,m1_,m2_);
    Double_t q0 = get_q(M0,m1_,m2_);
    return Blatt_Weisskopf(q,q0,L_);
  }


  std::complex<Double_t> BW_T(Double_t M, Double_t M0, Double_t Gamma0, Double_t m1_, Double_t m2_,  Double_t J_)const
    {
  // BW amplitude (i.e, not quared), to use for interferences. 
  // Gamma is phase space dependent
  // Uses Blatt-Weiskopff barrier factors from PDG
  // M : mass of the pair, M0: nominal mass of the resonance, Gamma0: nominal width of the resonance, ,
  // m1_: mass of one of the PSEUDOSCALAR daughters, m2_: mass of the other PSEUDOSCALAR daughter, 
  // J_ angular momentum quantum number of the resonance

  
  Double_t q = get_q(M,m1_,m2_);
  Double_t q0 = get_q(M0,m1_,m2_);

  Double_t Gamma = Gamma0*pow(q/q0,2*J_+1)*M0/M*Blatt_Weisskopf(q,q0,J_);

  std::complex<Double_t> denom(M*M-M0*M0,-Gamma*M0);
  std::complex<Double_t> num(1.,0.);

  //Double_t nu = TMath::Sqrt(mass0*mass0*(mass0*mass0+Gamma*Gamma));
  //std::complex<Double_t> k(TMath::Sqrt(2.*TMath::Sqrt(2.)*mass0*Gamma*nu/TMath::Pi()/TMath::Sqrt(mass0*mass0+nu)),0.);

  return num/denom;
    }


  Double_t get_K(Double_t M, Double_t M0, Double_t Gamma0, Double_t m1_, Double_t m2_,  Int_t J_ = 1)const
  {
  Double_t q = get_q(M,m1_,m2_);
  Double_t q0 = get_q(M0,m1_,m2_);
  Double_t Gamma = Gamma0*pow(q/q0,2*J_+1)*M0/M*Blatt_Weisskopf(q,q0,J_);

  return M0*Gamma/(M0*M0-M*M); 

  }

  Double_t get_K_hat(Double_t M, Double_t M0, Double_t Gamma0, Double_t m1_, Double_t m2_,  Int_t J_ = 1)const
  {

  //Double_t q = get_q(M,m1_,m2_);
  //Double_t q0 = get_q(M0,m1_,m2_);
  //Double_t Gamma = Gamma0*pow(q/q0,2*J_+1)*M0/M*Blatt_Weisskopf(q,q0,J_);

  return sqrt(M0*Gamma0)/(M0*M0-M*M); 

  }


protected:


  RooRealProxy m1 ;
  RooRealProxy m2 ;
  RooRealProxy m_kst ;
  RooRealProxy m_kst0 ;
  RooRealProxy g_kst ;
  RooRealProxy g_kst0 ;
  RooRealProxy MB ;
  RooListProxy acc_coefList;
  RooRealProxy norm;
  TIterator* coefIter;


private:

  ClassDef(MassK1,1) // Your description goes here...
};
 
#endif
