/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "AngF11.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(AngF11) 


 Double_t AngF11::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t c1_2 = c1*c1;
   Double_t c2_2 = c2*c2;
   Double_t s1_2 = 1.-c1_2;
   Double_t s2_2 = 1.-c2_2;
   Double_t s12s22 = s1_2*s2_2;
   Double_t s1s2 = sqrt(s12s22);

   Double_t coefsTH[5];
   Double_t coefsPH[5];

   getAccTHCoefs(coefsTH);
   getAccPHCoefs(coefsPH);

   Double_t c1_th = coefsTH[0];
   Double_t c2_th = coefsTH[1];
   Double_t c3_th = coefsTH[2];
   Double_t c4_th = coefsTH[3];
   Double_t c5_th = coefsTH[4];

   Double_t c1_ph = coefsPH[0];
   Double_t c2_ph = coefsPH[1];
   Double_t c3_ph = coefsPH[2];

   Double_t acc_th1 = 1. + c1_th*c1 + c2_th*c1_2 + c3_th*c1_2*c1 + c4_th*c1_2*c1_2 + c5_th*c1_2*c1_2*c1;
   Double_t acc_th2 = 1. + c1_th*c2 + c2_th*c2_2 + c3_th*c2_2*c2 + c4_th*c2_2*c2_2 + c5_th*c2_2*c2_2*c2;
   Double_t acc_phi = 1. + c1_ph*cos( c2_ph*ph + c3_ph);

   Double_t acc_val = acc_th1*acc_th2*acc_phi;

   if (acc_val<0){
     return 0.00001;
   }

   return  8*c1/(3*sqrt(3))*acc_val;
 } 

Double_t AngF11::analyticalIntegral(Int_t code, const char* rangeName) const
{

   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(binRange) AND x.max(binRange) WILL RETURN THE INTEGRATION1
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(binRange)-x.min(binRange)) ; 
   Double_t c1_2 = c1*c1;
   Double_t c2_2 = c2*c2;
   
   Double_t coefsTH[5];
   Double_t coefsPH[5];

   getAccTHCoefs(coefsTH);
   getAccPHCoefs(coefsPH);

   Double_t c1_th = coefsTH[0];
   Double_t c2_th = coefsTH[1];
   Double_t c3_th = coefsTH[2];
   Double_t c4_th = coefsTH[3];
   Double_t c5_th = coefsTH[4];

   Double_t c1_ph = coefsPH[0];
   Double_t c2_ph = coefsPH[1];
   Double_t c3_ph = coefsPH[2];

   Double_t acc_th1 = 1. + c1_th*c1 + c2_th*c1_2 + c3_th*c1_2*c1 + c4_th*c1_2*c1_2 + c5_th*c1_2*c1_2*c1;
   Double_t acc_th2 = 1. + c1_th*c2 + c2_th*c2_2 + c3_th*c2_2*c2 + c4_th*c2_2*c2_2 + c5_th*c2_2*c2_2*c2;
   Double_t acc_ph = 1. + c1_ph*cos( c2_ph*ph + c3_ph);

   double ic1;
   if (code==1 || code==2 || code==3 || code==5){
     Double_t hic1 = c1.max(rangeName);
     Double_t loc1 = c1.min(rangeName);

     double x1 = pow(hic1,2)/2. + (c1_th*pow(hic1,3))/3. + (c2_th*pow(hic1,4))/4. + (c3_th*pow(hic1,5))/5. + (c4_th*pow(hic1,6))/6. + (c5_th*pow(hic1,7))/7.;
     double y1 = pow(loc1,2)/2. + (c1_th*pow(loc1,3))/3. + (c2_th*pow(loc1,4))/4. + (c3_th*pow(loc1,5))/5. + (c4_th*pow(loc1,6))/6. + (c5_th*pow(loc1,7))/7.;

     ic1 = x1-y1;

   }else {
     ic1 = c1*acc_th1;
   }




   double ic2;
   if (code==1 || code==2 || code==4 || code==6){

     Double_t hic2 = c2.max(rangeName);
     Double_t loc2 = c2.min(rangeName);

     double x2 = hic2 + (c1_th*pow(hic2,2))/2. + (c2_th*pow(hic2,3))/3. + (c3_th*pow(hic2,4))/4. + (c4_th*pow(hic2,5))/5. + (c5_th*pow(hic2,6))/6.;
     double y2 = loc2 + (c1_th*pow(loc2,2))/2. + (c2_th*pow(loc2,3))/3. + (c3_th*pow(loc2,4))/4. + (c4_th*pow(loc2,5))/5. + (c5_th*pow(loc2,6))/6.;

     ic2 = x2-y2;

   }else {
   
     ic2 = acc_th2;

   }


   double iph;
   if (code==1 || code==3 || code==4 || code==7 ){

     Double_t hiph = ph.max(rangeName);
     //cout << "hiph: "<< hiph << endl;
     Double_t loph = ph.min(rangeName);
     //cout << "loph: "<< loph << endl;

     Double_t iphhi = hiph + c1_ph*cos(c2_ph*hiph)*sin(c3_ph)/c2_ph + c1_ph*cos(c3_ph)*sin(c2_ph*hiph)/c2_ph;
     //cout << "iphhi: " << c1_ph*cos(c2_ph*hiph)*sin(c3_ph)/c2_ph << endl;
     Double_t iphlo = loph + c1_ph*cos(c2_ph*loph)*sin(c3_ph)/c2_ph + c1_ph*cos(c3_ph)*sin(c2_ph*loph)/c2_ph;
     //cout << "iphlo: " << iphlo << endl;

     iph = iphhi - iphlo;
     //cout << "iph: " << iph << endl;

   }else{

     iph = acc_ph;

   }


   return 8*ic1*ic2*iph/(3*sqrt(3));

}



