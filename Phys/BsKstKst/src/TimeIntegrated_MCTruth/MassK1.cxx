/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "MassK1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TComplex.h"
#include <complex>

#include <vector>
using std::vector;

#include <iostream>
using std::ios;
#include <fstream>
#include <iomanip>
#include <sstream>


#include "BWtools.C"


#define qr 197.3


ClassImp(MassK1) 


  MassK1::MassK1(const char *name, const char *title,
                          RooAbsReal& _m1,
                          RooAbsReal& _m2,
                          RooAbsReal& _m_kst,
                          RooAbsReal& _m_kst0,
                          RooAbsReal& _g_kst,
                          RooAbsReal& _g_kst0,
                           RooAbsReal& _m_Bs,
                          RooArgList& _acc_coefList,
                          RooAbsReal& _norm):
    RooAbsReal(name,title),
    m1("m1","m1",this,_m1),
    m2("m2","m2",this,_m2),
    m_kst("m_kst","m_kst",this,_m_kst),
    m_kst0("m_kst0","m_kst0",this,_m_kst0),
    g_kst("g_kst","g_kst",this,_g_kst),
    g_kst0("g_kst0","g_kst0",this,_g_kst0),
    MB("MB","MB",this,_m_Bs),
    acc_coefList("acc_coefList","List of acc coefficients",this),
    norm("norm","norm",this,_norm)
{
  TIterator* _coefIter = _acc_coefList.createIterator();
  coefIter = acc_coefList.createIterator();

  RooAbsArg* coef ;

  while((coef = (RooAbsArg*)_coefIter->Next())) {
    if (!dynamic_cast<RooAbsReal*>(coef)) {
      cout << "RooPolynomial::ctor(" << GetName() << ") ERROR: coefficient " << coef->GetName()
           << " is not of type RooAbsReal" << endl ;
      assert(0) ;
    }
    acc_coefList.add(*coef) ;
  }

  delete _coefIter ;

}


 MassK1::MassK1(const MassK1& other, const char* name) :
   RooAbsReal(other,name),
   m1("m1",this,other.m1),
   m2("m2",this,other.m2),
   m_kst("m_kst",this,other.m_kst),
   m_kst0("m_kst0",this,other.m_kst0),
   g_kst("g_kst",this,other.g_kst),
   g_kst0("g_kst0",this,other.g_kst0),
   MB("MB",this,other.MB),
   acc_coefList("acc_coefList",this,other.acc_coefList),
   norm("norm",this,other.norm)
 {
   

   coefIter = acc_coefList.createIterator();

 }



Double_t MassK1::calculatePDF_1D(Int_t indx)const
{


  Double_t m_kst_=m_kst;
  Double_t m_kstb_=m_kst;
  
  if (indx==1)
    {
      m_kst_ = m1;
      m_kstb_ = m2;
    }
  else
    {
      m_kst_ = m2;
      m_kstb_ = m1;
    }

   Double_t K0 = get_K(m_kst_,m_kst,g_kst,mDa,mDb,j);
   Double_t K0h = get_K_hat(m_kst_,m_kst,g_kst,mDa,mDb,j);

   Double_t q = get_q(m_kst_,mDa,mDb);
   Double_t q0 = get_q(m_kst,mDa,mDb);
   if (q==0) return 0;
   Double_t rho_decay = pow(q,2*j+1)*Blatt_Weisskopf(q,q0,j);


   Double_t p = get_q(MB,m_kstb_,m_kst_);
   Double_t p0 = get_q(MB,m_kstb_,m_kst);
   if (p==0) return 0;
   Double_t rho_birth = pow(p,2*l+1)*Blatt_Weisskopf(p,p0,l);

   std::complex<Double_t> num(K0h,0.); 
   std::complex<Double_t> den(1, -(K0)); 
   std::complex<Double_t> T = num/den;
   Double_t  kst1 = real(T*conj(T));

   return kst1 * rho_decay * rho_birth;



}



Double_t MassK1::getPDF_1D(Double_t m_kst_, Double_t m_kstb_)const
{

  
   Double_t K0 = get_K(m_kst_,m_kst,g_kst,mDa,mDb,j);
   Double_t K0h = get_K_hat(m_kst_,m_kst,g_kst,mDa,mDb,j);

   Double_t q = get_q(m_kst_,mDa,mDb);
   Double_t q0 = get_q(m_kst,mDa,mDb);
   if (q==0) return 0;
   Double_t rho_decay = pow(q,2*j+1)*Blatt_Weisskopf(q,q0,j);


   Double_t p = get_q(MB,m_kstb_,m_kst_);
   Double_t p0 = get_q(MB,m_kstb_,m_kst);
   if (p==0) return 0;
   Double_t rho_birth = pow(p,2*l+1)*Blatt_Weisskopf(p,p0,l);

   std::complex<Double_t> num(K0h,0.); 
   std::complex<Double_t> den(1, -(K0)); 
   std::complex<Double_t> T = num/den;
   Double_t  kst1 = real(T*conj(T));

   return kst1 * rho_decay * rho_birth;


}


Double_t MassK1::getPDF_2D(Double_t mkst, Double_t mkstb)const
{
  Double_t PDF_1 = getPDF_1D(mkst,mkstb);
  Double_t PDF_2 = getPDF_1D(mkstb,mkst);

   return PDF_1*PDF_2;

}





 Double_t MassK1::evaluate() const 
 { 
   Double_t PDF_1 = calculatePDF_1D(1);
   Double_t PDF_2 = calculatePDF_1D(2);

   return PDF_1*PDF_2*norm;



 } 




Int_t MassK1::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   if (matchArgs(allVars,analVars,m1,m2)) return 0;
//      {
//        cout << "returning: 3"<<endl;
//        return 3 ;
//      }
   if (matchArgs(allVars,analVars,m1))
     {
       cout << "returning: 1"<<endl;
       return 1 ;
     } 
   if (matchArgs(allVars,analVars,m2))
     {
       cout << "returning: 2"<<endl;
       return 2 ;
     }
   

return 0 ; 
 } 




 Double_t MassK1::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 



   if (code==1){
     Int_t n;
     Double_t xmin,xmax,sum,f1,f2,f3,d1,d2,e,error,beta1,beta2,delta,beta,x1,x2;
     n=1000;
     n=3*n;

     xmin=m1.min(rangeName);
     xmax=MB-m2;


     delta=(xmax-xmin)/n;
     sum=0.0;
     error=0.0;
     for(Int_t i=0;i<n;i=i+1)
       {
	 x1=xmin+i*delta;
	 x2=xmin+(i+1)*delta;
	 beta1=(x2+x1)/2;
	 beta2=(x2-x1)/2;
	 f1=getPDF_2D(beta1-sqrt(3/5)*beta2,m2);
	 f2=getPDF_2D(beta1,m2);
	 f3=getPDF_2D(beta1+sqrt(3/5)*beta2,m2);
	 sum=sum+beta2*(5.0/9.0*(f1+f3)+8.0/9.0*f2);
         
       }
     return sum*norm;

  
//      beta=(xmax-xmin)/(2*n);
//      sum=0.0;
//      error=0.0;
//      for(Int_t i=2;i<n;i=i+3)
//        {
// 	 f1=getPDF_2D(xmin+(i-1)*beta,m2);
// 	 f2=getPDF_2D(xmin+i*beta,m2);
// 	 f3=getPDF_2D(xmin+(i+1)*beta,m2);
// 	 sum=sum+beta*(5.0/9.0*(f1+f3)+8.0/9.0*f2);
// // 	 d1=abs(getPDF_2D(m1,m2-i*beta)-getPDF_2D(m1,m2-i*beta))/beta;
// // 	 d2=abs(getPDF_2D(m1,m2-i*beta)-getPDF_2D(m1,m2+i*beta))/beta;
// // 	 if(d1<d2) e=d2;
// // 	 else e=d1;
// // 	 error=error+e;
//        }
//      return sum;
   }

   else if (code==2){
     Int_t n;
     Double_t xmin,xmax,sum,f1,f2,f3,d1,d2,e,error,beta1,beta2,delta,beta,x1,x2;
     n=10000;
     n=3*n;

     xmin=m1.min(rangeName);
     xmax=MB-m1;
  
     delta=(xmax-xmin)/n;
     sum=0.0;
     error=0.0;
     for(Int_t i=0;i<n;i=i+1)
       {
	 x1=xmin+i*delta;
	 x2=xmin+(i+1)*delta;
	 beta1=(x2+x1)/2;
	 beta2=(x2-x1)/2;
	 f1=getPDF_2D(m1,beta1-sqrt(3/5)*beta2);
	 f2=getPDF_2D(m1,beta1);
	 f3=getPDF_2D(m1,beta1+sqrt(3/5)*beta2);
	 sum=sum+beta2*(5.0/9.0*(f1+f3)+8.0/9.0*f2);
         
       }
     return sum*norm;

//      beta=(xmax-xmin)/(2*n);
//      sum=0.0;
//      error=0.0;
//      for(Int_t i=2;i<n;i=i+3)
//        {
// 	 f1=getPDF_2D(m1,xmin+(i-1)*beta);
// 	 f2=getPDF_2D(m1,xmin+i*beta);
// 	 f3=getPDF_2D(m1,xmin+(i+1)*beta);
// 	 sum=sum+beta*(5.0/9.0*(f1+f3)+8.0/9.0*f2);
// // 	 d1=abs(getPDF_2D(m1,m2-i*beta)-getPDF_2D(m1,m2-i*beta))/beta;
// // 	 d2=abs(getPDF_2D(m1,m2-i*beta)-getPDF_2D(m1,m2+i*beta))/beta;
// // 	 if(d1<d2) e=d2;
// // 	 else e=d1;
// // 	 error=error+e;
//        }
//      return sum;

   }

   else
     {

       return 1.1406*pow(10,19)*norm;
     }


   return 0 ; 
 } 

