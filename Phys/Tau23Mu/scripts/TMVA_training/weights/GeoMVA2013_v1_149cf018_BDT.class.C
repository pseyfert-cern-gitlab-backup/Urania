// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/07       [336391]
Creator        : pseyfert
Date           : Tue Dec 17 05:03:31 2013
Host           : Linux lxbuild175.cern.ch 2.6.18-308.4.1.el5 #1 SMP Wed Apr 18 16:26:27 CEST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /auto/sigma0/pseyfert/zoontuple/Bender_v22r7/Phys/Tau23Mu/scripts/TMVA_training
Training events: 41393
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
AdaBoostBeta: "5.000000e-01" [Parameter for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "1880" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "20" [Number of steps during node cut optimisation]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
MaxDepth: "4" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "4" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "41393" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 14
TMath::Exp(-1000*LifeTime)    TMath_Exp__M_1000_T_LifeTime_ TMath::Exp(-1000*LifeTime)    transformed decay time        1                                 'F'    [1.93987222119e-11,0.731256723404]
IPSig                         IPSig                         IPSig                         IP significance               1                                 'F'    [0.0111495917663,24.9779434204]
VertexChi2                    VertexChi2                    VertexChi2                    vertex #chi^{2}               1                                 'F'    [0.00189490010962,14.9983968735]
acos(dira)                    acos_dira_                    acos(dira)                    pointing angle                1                                 'F'    [0,0.137716650963]
pt                            pt                            pt                            p_{T}                         [MeV/c]                           'F'    [41.2933425903,37961.9179688]
min(p0_IPSig,min(p1_IPSig,p2_IPSig)) min_p0_IPSig,min_p1_IPSig,p2_IPSig__ min(p0_IPSig,min(p1_IPSig,p2_IPSig)) min. #mu IP significance             1                                        'F'    [2.30495882034,102.738922119]
DOCAone                       DOCAone                       DOCAone                       DOCA (#mu 1 and 2)            mm                                'F'    [2.63570382231e-06,0.923672735691]
DOCAtwo                       DOCAtwo                       DOCAtwo                       DOCA (#mu 2 and 3)            mm                                'F'    [2.4348450367e-08,0.744905769825]
DOCAthree                     DOCAthree                     DOCAthree                     DOCA (#mu 1 and 3)            mm                                'F'    [6.10736776707e-07,1.05343544483]
iso                           iso                           iso                           track isolation               1                                 'F'    [0,17]
CDF3                          CDF3                          CDF3                          cone isolation                1                                 'F'    [0.00300450995564,1]
p0_track_MatchChi2            p0_track_MatchChi2            p0_track_MatchChi2            track match #chi^{2} (#mu 1)  1                                 'F'    [0.0559116005898,84.5542831421]
p1_track_MatchChi2            p1_track_MatchChi2            p1_track_MatchChi2            track match #chi^{2} (#mu 2)  1                                 'F'    [0.0131226135418,75.9046707153]
p2_track_MatchChi2            p2_track_MatchChi2            p2_track_MatchChi2            track match #chi^{2} (#mu 3)  1                                 'F'    [0.0151327997446,79.3785171509]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 14 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TMath::Exp(-1000*LifeTime)", "IPSig", "VertexChi2", "acos(dira)", "pt", "min(p0_IPSig,min(p1_IPSig,p2_IPSig))", "DOCAone", "DOCAtwo", "DOCAthree", "iso", "CDF3", "p0_track_MatchChi2", "p1_track_MatchChi2", "p2_track_MatchChi2" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 1.93987222119052e-11;
      fVmax[0] = 0.731256723403931;
      fVmin[1] = 0.0111495917662978;
      fVmax[1] = 24.9779434204102;
      fVmin[2] = 0.0018949001096189;
      fVmax[2] = 14.9983968734741;
      fVmin[3] = 0;
      fVmax[3] = 0.13771665096283;
      fVmin[4] = 41.293342590332;
      fVmax[4] = 37961.91796875;
      fVmin[5] = 2.30495882034302;
      fVmax[5] = 102.738922119141;
      fVmin[6] = 2.63570382230682e-06;
      fVmax[6] = 0.923672735691071;
      fVmin[7] = 2.43484503670288e-08;
      fVmax[7] = 0.744905769824982;
      fVmin[8] = 6.10736776707199e-07;
      fVmax[8] = 1.05343544483185;
      fVmin[9] = 0;
      fVmax[9] = 17;
      fVmin[10] = 0.00300450995564461;
      fVmax[10] = 1;
      fVmin[11] = 0.0559116005897522;
      fVmax[11] = 84.5542831420898;
      fVmin[12] = 0.0131226135417819;
      fVmax[12] = 75.904670715332;
      fVmin[13] = 0.015132799744606;
      fVmax[13] = 79.3785171508789;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[14];
   double fVmax[14];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[14];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1.20102040203471);
  fForest.push_back( 
NN(
0, 
0, 
-1, 0.0196738, 1, 1, 0.916983,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.730999);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.61905, 1, 1, 0.913304,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.14286, 1, 1, 0.720156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471428,-99) , 
0, 0.343445, 1, 0, 0.643077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340334,-99) , 
2, 7.14107, 1, 0, 0.552969,-99) , 
1, 4.76673, 1, 0, 0.768706,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.555719);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.33333, 1, 1, 0.87148,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.821954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495767,-99) , 
3, 0.0187072, 1, 0, 0.592371,-99) , 
1, 3.7926, 1, 0, 0.639667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527667,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315351,-99) , 
2, 4.28651, 1, 0, 0.410256,-99) , 
9, 1.61905, 1, 0, 0.550803,-99) , 
3, 0.00655794, 1, 0, 0.712446,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.412595);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.61905, 1, 1, 0.826672,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 9.71469, 1, 1, 0.649891,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430906,-99) , 
2, 5.00298, 1, 0, 0.512572,-99) , 
5, 7.38226, 0, 0, 0.585063,-99) , 
NN(
0, 
0, 
-1, 3499.26, 0, -1, 0.416121,-99) , 
9, 1.42857, 1, 0, 0.525386,-99) , 
1, 3.57783, 1, 0, 0.649201,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.320375);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.666667, 1, 1, 0.824369,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 8.84217, 1, 1, 0.592464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441971,-99) , 
0, 0.522326, 1, 0, 0.571988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351074,-99) , 
11, 12.1586, 1, 0, 0.54275,-99) , 
1, 2.38894, 1, 0, 0.61553,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.273431);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.666667, 1, 1, 0.773092,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 3.925, 1, 1, 0.624781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38701,-99) , 
1, 4.84779, 0, 0, 0.467012,-99) , 
9, 0.809524, 1, 0, 0.550645,-99) , 
NN(
0, 
0, 
-1, 5.70914, 0, -1, 0.424772,-99) , 
1, 8.84295, 1, 0, 0.503204,-99) , 
1, 2.38894, 1, 0, 0.569003,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.216149);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.851813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454172,-99) , 
9, 0.666667, 1, 0, 0.721602,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 3.56929, 1, 1, 0.638701,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426994,-99) , 
11, 8.13658, 1, 0, 0.500864,-99) , 
1, 3.46498, 1, 0, 0.521642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404752,-99) , 
6, 0.0879717, 1, 0, 0.503679,-99) , 
1, 2.38894, 1, 0, 0.554717,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.2036);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.666667, 1, 1, 0.714657,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 3.56939, 1, 1, 0.657344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459832,-99) , 
2, 6.42743, 0, 0, 0.490845,-99) , 
1, 4.54063, 1, 0, 0.52398,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477228,-99) , 
1, 4.05362, 1, 0, 0.497336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377168,-99) , 
5, 4.3546, 0, 0, 0.452381,-99) , 
5, 7.08753, 0, 0, 0.48766,-99) , 
1, 2.38894, 1, 0, 0.539122,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.167723);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.790699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457284,-99) , 
9, 0.666667, 1, 0, 0.671396,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.0343598, 1, 1, 0.544157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441209,-99) , 
2, 4.67534, 0, 0, 0.489113,-99) , 
7, 0.0332957, 1, 0, 0.521738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407294,-99) , 
2, 10.7098, 1, 0, 0.508179,-99) , 
1, 2.38894, 1, 0, 0.544306,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.171417);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.761591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499111,-99) , 
9, 0.666667, 1, 0, 0.66508,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481105,-99) , 
2, 4.28391, 1, 0, 0.552494,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444775,-99) , 
3, 0.00538356, 1, 0, 0.47966,-99) , 
0, 0.345886, 0, 0, 0.508853,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471235,-99) , 
10, 0.34435, 1, 0, 0.497375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380026,-99) , 
5, 4.77676, 0, 0, 0.460307,-99) , 
6, 0.0439875, 1, 0, 0.489797,-99) , 
1, 2.38894, 1, 0, 0.527812,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.137558);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.720287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461734,-99) , 
2, 7.14309, 1, 0, 0.658252,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 6.59658, 1, 1, 0.58944,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453713,-99) , 
5, 4.46788, 0, 0, 0.50464,-99) , 
5, 12.8587, 0, 0, 0.518545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514512,-99) , 
NN(
0, 
0, 
-1, 3159.92, 1, -1, 0.442355,-99) , 
4, 4702.62, 0, 0, 0.465714,-99) , 
12, 7.24089, 1, 0, 0.504219,-99) , 
1, 2.38894, 1, 0, 0.537157,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.142556);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28661, 1, 1, 0.703043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46918,-99) , 
3, 0.00496557, 1, 0, 0.643883,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605407,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448169,-99) , 
8, 0.0292012, 0, 0, 0.495861,-99) , 
1, 6.0765, 1, 0, 0.523477,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441165,-99) , 
2, 6.42682, 1, 0, 0.500158,-99) , 
NN(
0, 
0, 
-1, 0.272635, 1, -1, 0.454215,-99) , 
0, 0.333296, 0, 0, 0.480648,-99) , 
0, 0.174109, 1, 0, 0.49248,-99) , 
1, 2.38894, 1, 0, 0.524369,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.137454);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.513851, 1, 1, 0.70706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438417,-99) , 
4, 4318.67, 0, 0, 0.513291,-99) , 
2, 5.00073, 1, 0, 0.629238,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494494,-99) , 
10, 0.43076, 0, 0, 0.528342,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473422,-99) , 
8, 0.0262772, 1, 0, 0.549401,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451222,-99) , 
9, 1.14286, 0, 0, 0.472987,-99) , 
1, 3.27514, 1, 0, 0.48473,-99) , 
3, 0.0196738, 0, 0, 0.495494,-99) , 
1, 2.38894, 1, 0, 0.523305,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.175133);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00200787, 1, 1, 0.67935,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585736,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46306,-99) , 
5, 12.2822, 0, 0, 0.484739,-99) , 
3, 0.0191579, 0, 0, 0.508831,-99) , 
1, 3.15066, 1, 0, 0.562803,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446973,-99) , 
2, 4.28651, 0, 0, 0.498892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378276,-99) , 
1, 4.76818, 0, 0, 0.455193,-99) , 
9, 1.61905, 1, 0, 0.527848,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.133626);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.239292, 0, 1, 0.749978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459404,-99) , 
2, 7.1425, 1, 0, 0.567471,-99) , 
3, 0.00200787, 1, 0, 0.622244,-99) , 
NN(
NN(
0, 
0, 
-1, 2425.14, 1, 1, 0.556856,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469391,-99) , 
1, 6.69324, 1, 0, 0.495877,-99) , 
4, 3160.04, 1, 0, 0.513891,-99) , 
1, 3.15066, 1, 0, 0.546598,-99) , 
NN(
0, 
0, 
-1, 5.99535, 0, -1, 0.44524,-99) , 
9, 2.42857, 1, 0, 0.526751,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.1003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.85202, 1, 1, 0.672465,-99) , 
NN(
NN(
0, 
0, 
-1, 3.01805, 1, 1, 0.536449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434853,-99) , 
0, 0.59197, 1, 0, 0.528651,-99) , 
1, 1.04627, 1, 0, 0.536126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39659,-99) , 
11, 16.1508, 1, 0, 0.525562,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.087827);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.85595, 1, 1, 0.631545,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692451,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498606,-99) , 
2, 4.29689, 1, 0, 0.594137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518104,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476696,-99) , 
9, 0.619048, 1, 0, 0.498691,-99) , 
1, 2.33241, 1, 0, 0.509364,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411266,-99) , 
6, 0.0228006, 1, 0, 0.457943,-99) , 
0, 0.487504, 1, 0, 0.499108,-99) , 
1, 1.20004, 1, 0, 0.50771,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.085158);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 7.61718, 0, 1, 0.718968,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466699,-99) , 
1, 1.4861, 1, 0, 0.544589,-99) , 
6, 0.0167501, 1, 0, 0.59889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437861,-99) , 
6, 0.0703422, 1, 0, 0.562176,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562697,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455411,-99) , 
10, 0.620486, 1, 0, 0.490922,-99) , 
5, 13.0373, 0, 0, 0.499266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438771,-99) , 
0, 0.0696435, 0, 0, 0.492983,-99) , 
1, 2.38894, 1, 0, 0.506638,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.100287);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0256496, 1, 1, 0.674474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471571,-99) , 
0, 0.297321, 0, 0, 0.54395,-99) , 
2, 4.28661, 1, 0, 0.611039,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411731,-99) , 
6, 0.0224631, 1, 0, 0.477585,-99) , 
0, 0.479606, 1, 0, 0.564063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478228,-99) , 
8, 0.0153703, 1, 0, 0.520303,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475316,-99) , 
0, 0.243116, 1, 0, 0.498681,-99) , 
NN(
0, 
0, 
-1, 0.348218, 0, -1, 0.465303,-99) , 
2, 5.9511, 0, 0, 0.479481,-99) , 
2, 1.43003, 1, 0, 0.485646,-99) , 
1, 2.38894, 1, 0, 0.501031,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0975527);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00200787, 1, 1, 0.613813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422626,-99) , 
9, 1.33333, 1, 0, 0.562987,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47961,-99) , 
2, 2.85954, 1, 0, 0.492009,-99) , 
11, 8.5035, 0, 0, 0.502061,-99) , 
1, 3.1165, 1, 0, 0.518923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425398,-99) , 
11, 16.1508, 1, 0, 0.511877,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0542217);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.85595, 1, 1, 0.586695,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.19002, 1, 1, 0.536776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453572,-99) , 
13, 9.79964, 1, 0, 0.499085,-99) , 
12, 3.62701, 1, 0, 0.512058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45165,-99) , 
0, 0.59197, 1, 0, 0.507472,-99) , 
1, 1.20004, 1, 0, 0.512453,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.100375);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.777954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491756,-99) , 
1, 1.78514, 0, 0, 0.554506,-99) , 
1, 0.803724, 1, 0, 0.582171,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418838,-99) , 
5, 7.11865, 0, 0, 0.470598,-99) , 
11, 6.66005, 1, 0, 0.541752,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476515,-99) , 
2, 9.75888, 1, 0, 0.515144,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463774,-99) , 
1, 4.9752, 0, 0, 0.510773,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457267,-99) , 
1, 4.25585, 1, 0, 0.470317,-99) , 
0, 0.348217, 0, 0, 0.485317,-99) , 
2, 7.14064, 0, 0, 0.493845,-99) , 
1, 2.38894, 1, 0, 0.503097,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0763377);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 7.61718, 0, 1, 0.680369,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473746,-99) , 
1, 1.4861, 1, 0, 0.53397,-99) , 
6, 0.0167501, 1, 0, 0.578288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454845,-99) , 
6, 0.0703422, 1, 0, 0.549798,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466815,-99) , 
1, 4.54029, 0, 0, 0.517058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462538,-99) , 
6, 0.00705092, 0, 0, 0.503701,-99) , 
NN(
0, 
0, 
-1, 5.67587, 1, -1, 0.465991,-99) , 
6, 0.0493408, 1, 0, 0.493503,-99) , 
2, 7.14064, 0, 0, 0.500238,-99) , 
1, 2.38894, 1, 0, 0.509769,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0695146);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.376872, 1, 1, 0.626805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46438,-99) , 
12, 8.44967, 1, 0, 0.59125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574843,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436651,-99) , 
2, 2.85803, 1, 0, 0.482004,-99) , 
11, 6.66005, 1, 0, 0.551505,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495619,-99) , 
4, 2660.9, 1, 0, 0.510953,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432739,-99) , 
0, 0.343264, 0, 0, 0.488393,-99) , 
0, 0.278574, 1, 0, 0.499058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466434,-99) , 
12, 10.8548, 1, 0, 0.495534,-99) , 
1, 2.38894, 1, 0, 0.506258,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0844068);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 9.81501, 0, 1, 0.610301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460643,-99) , 
0, 0.159918, 0, 0, 0.583447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421805,-99) , 
1, 1.3706, 1, 0, 0.48281,-99) , 
0, 0.479606, 1, 0, 0.54777,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2916.39, 1, 1, 0.541327,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439394,-99) , 
0, 0.0795651, 0, 0, 0.491671,-99) , 
3, 0.00951174, 0, 0, 0.514839,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463834,-99) , 
5, 7.18202, 1, 0, 0.493384,-99) , 
NN(
0, 
0, 
-1, 6.57983, 0, -1, 0.453142,-99) , 
2, 2.85769, 0, 0, 0.480274,-99) , 
0, 0.278574, 1, 0, 0.496664,-99) , 
1, 2.38894, 1, 0, 0.506417,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0599035);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0217841, 1, 1, 0.725839,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474748,-99) , 
12, 2.89794, 1, 0, 0.515034,-99) , 
3, 0.00165519, 1, 0, 0.5778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487727,-99) , 
9, 0.666667, 1, 0, 0.541302,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530648,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482429,-99) , 
2, 3.57161, 1, 0, 0.493844,-99) , 
11, 10.9929, 0, 0, 0.499699,-99) , 
NN(
0, 
0, 
-1, 4.14797, 1, -1, 0.467681,-99) , 
0, 0.417861, 1, 0, 0.490856,-99) , 
1, 2.38894, 1, 0, 0.500442,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.067177);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 5.00667, 1, 1, 0.619392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489106,-99) , 
3, 0.00496557, 1, 0, 0.581902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590881,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453718,-99) , 
5, 7.11865, 0, 0, 0.490103,-99) , 
11, 6.66005, 1, 0, 0.548557,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539481,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47565,-99) , 
1, 5.93368, 1, 0, 0.492638,-99) , 
3, 0.0187306, 0, 0, 0.499382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466778,-99) , 
3, 0.0262317, 1, 0, 0.494617,-99) , 
1, 2.38894, 1, 0, 0.504844,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0726066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 6.55939, 1, 1, 0.588233,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0484572, 0, 1, 0.548471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436945,-99) , 
13, 3.36566, 0, 0, 0.505712,-99) , 
2, 4.28661, 1, 0, 0.547126,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482236,-99) , 
9, 0.619048, 0, 0, 0.513174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587777,-99) , 
NN(
0, 
0, 
-1, 4.74518, 0, -1, 0.477827,-99) , 
1, 2.69625, 1, 0, 0.484862,-99) , 
1, 8.84295, 0, 0, 0.495817,-99) , 
1, 2.38894, 1, 0, 0.505517,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0538608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.04627, 1, 1, 0.525788,-99) , 
NN(
0, 
0, 
-1, 0.0348625, 0, -1, 0.480886,-99) , 
9, 2.42857, 1, 0, 0.516807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442973,-99) , 
11, 16.1508, 1, 0, 0.511251,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0473669);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568393,-99) , 
NN(
NN(
0, 
0, 
-1, 1879.03, 1, 1, 0.518851,-99) , 
NN(
0, 
0, 
-1, 9.06486, 1, -1, 0.481287,-99) , 
11, 5.52977, 1, 0, 0.504573,-99) , 
11, 11.5515, 0, 0, 0.508742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456301,-99) , 
11, 16.1508, 1, 0, 0.504802,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0699624);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.57028, 0, 1, 0.56009,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44807,-99) , 
1, 2.88497, 1, 0, 0.470705,-99) , 
10, 0.667943, 1, 0, 0.524917,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562684,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484946,-99) , 
13, 7.03251, 0, 0, 0.494945,-99) , 
4, 1847.01, 1, 0, 0.502631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433627,-99) , 
13, 11.3528, 1, 0, 0.495436,-99) , 
4, 5458.53, 0, 0, 0.502525,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0403622);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569038,-99) , 
NN(
NN(
0, 
0, 
-1, 2.38894, 1, 1, 0.512614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452051,-99) , 
0, 0.484552, 1, 0, 0.507386,-99) , 
0, 0.535559, 0, 0, 0.511094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464987,-99) , 
0, 0.59197, 1, 0, 0.507393,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0599698);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 7.61718, 0, 1, 0.635927,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480798,-99) , 
7, 0.0435682, 0, 0, 0.507527,-99) , 
6, 0.0167501, 1, 0, 0.545233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455566,-99) , 
6, 0.0703422, 1, 0, 0.524197,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55738,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462401,-99) , 
7, 0.0162484, 0, 0, 0.493981,-99) , 
7, 0.00337834, 1, 0, 0.498946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473353,-99) , 
7, 0.0709435, 1, 0, 0.494942,-99) , 
1, 2.38894, 1, 0, 0.50043,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0721508);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.803724, 1, 1, 0.582129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433824,-99) , 
0, 0.342812, 0, 0, 0.481302,-99) , 
11, 6.6384, 1, 0, 0.543263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443192,-99) , 
13, 9.86242, 1, 0, 0.528336,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483132,-99) , 
5, 6.96636, 1, 0, 0.517976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466472,-99) , 
1, 4.54029, 0, 0, 0.504651,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564872,-99) , 
NN(
0, 
0, 
-1, 7.08595, 0, -1, 0.477555,-99) , 
5, 16.6527, 0, 0, 0.484971,-99) , 
2, 5.71299, 0, 0, 0.492461,-99) , 
1, 2.38894, 1, 0, 0.499178,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.072301);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0352396, 1, 1, 0.567682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440296,-99) , 
9, 1.33333, 1, 0, 0.532942,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497689,-99) , 
4, 4478.16, 0, 0, 0.515481,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524435,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457585,-99) , 
5, 7.38226, 0, 0, 0.490026,-99) , 
2, 3.81157, 0, 0, 0.502957,-99) , 
1, 3.15066, 1, 0, 0.510991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468019,-99) , 
2, 11.4278, 1, 0, 0.50704,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0437329);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54813,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487702,-99) , 
0, 0.313418, 0, 0, 0.503689,-99) , 
4, 1847.04, 1, 0, 0.507531,-99) , 
11, 11.5515, 0, 0, 0.51117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473465,-99) , 
11, 16.1508, 1, 0, 0.508329,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0557023);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586447,-99) , 
NN(
NN(
0, 
0, 
-1, 9.76174, 1, 1, 0.538344,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440704,-99) , 
13, 11.3528, 1, 0, 0.500537,-99) , 
2, 7.14341, 0, 0, 0.510398,-99) , 
4, 1492.09, 1, 0, 0.515508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 5922.49, 1, 1, 0.582862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488974,-99) , 
3, 0.00638595, 1, 0, 0.517602,-99) , 
NN(
0, 
0, 
-1, 3.70784, 0, -1, 0.46045,-99) , 
6, 0.0348354, 1, 0, 0.489866,-99) , 
0, 0.417861, 1, 0, 0.507518,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0504754);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586222,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489283,-99) , 
3, 0.00597815, 1, 0, 0.500856,-99) , 
4, 3376.36, 0, 0, 0.531398,-99) , 
NN(
NN(
0, 
0, 
-1, 12.6201, 1, 1, 0.539833,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484654,-99) , 
13, 1.90813, 1, 0, 0.49155,-99) , 
13, 9.82552, 0, 0, 0.497661,-99) , 
10, 0.335336, 1, 0, 0.505419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478418,-99) , 
9, 3.2381, 1, 0, 0.502296,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0834507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 6.96636, 1, 1, 0.53406,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441025,-99) , 
10, 0.478169, 1, 0, 0.47037,-99) , 
3, 0.0131972, 0, 0, 0.496631,-99) , 
2, 4.28651, 0, 0, 0.515461,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463691,-99) , 
3, 0.0052561, 1, 0, 0.531128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452053,-99) , 
9, 1.33333, 1, 0, 0.510998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432896,-99) , 
3, 0.0110478, 1, 0, 0.497844,-99) , 
1, 4.76673, 0, 0, 0.508133,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0545896);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.615225, 1, 1, 0.547872,-99) , 
NN(
NN(
0, 
0, 
-1, 1.03004, 1, 1, 0.513921,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448998,-99) , 
9, 2.47619, 1, 0, 0.502791,-99) , 
0, 0.557148, 0, 0, 0.509829,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492039,-99) , 
2, 4.27918, 0, 0, 0.514869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468301,-99) , 
0, 0.312619, 1, 0, 0.496663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446578,-99) , 
3, 0.00712748, 0, 0, 0.488024,-99) , 
1, 7.14452, 1, 0, 0.500746,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0524136);
  fForest.push_back( 
NN(
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490143,-99) , 
4, 4130.64, 1, 0, 0.53677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482632,-99) , 
4, 5062.93, 0, 0, 0.49486,-99) , 
8, 0.0525451, 0, 0, 0.505131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412,-99) , 
1, 3.6456, 0, 0, 0.472526,-99) , 
8, 0.100328, 1, 0, 0.500279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465957,-99) , 
10, 0.857572, 1, 0, 0.497939,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.050102);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543286,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478002,-99) , 
12, 7.26687, 1, 0, 0.503763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443075,-99) , 
10, 0.857572, 1, 0, 0.499011,-99) , 
8, 0.0716522, 0, 0, 0.504,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43287,-99) , 
8, 0.145714, 1, 0, 0.478179,-99) , 
8, 0.100328, 1, 0, 0.500304,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0427025);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540112,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490395,-99) , 
0, 0.452698, 0, 0, 0.50021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448234,-99) , 
8, 0.100328, 1, 0, 0.494608,-99) , 
4, 1847.04, 1, 0, 0.498562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469009,-99) , 
2, 11.4278, 1, 0, 0.495839,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0255087);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556452,-99) , 
NN(
NN(
0, 
0, 
-1, 1623.34, 1, 1, 0.50461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455106,-99) , 
0, 0.484552, 1, 0, 0.500304,-99) , 
0, 0.535559, 0, 0, 0.503672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467444,-99) , 
0, 0.59197, 1, 0, 0.50075,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0279774);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543394,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452105,-99) , 
11, 9.36148, 1, 0, 0.499211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458537,-99) , 
2, 11.4278, 1, 0, 0.495412,-99) , 
11, 11.5515, 0, 0, 0.498526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469885,-99) , 
11, 16.1508, 1, 0, 0.49636,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0457021);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607143,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498407,-99) , 
2, 2.86062, 1, 0, 0.533176,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463235,-99) , 
4, 5495.13, 1, 0, 0.497458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439989,-99) , 
6, 0.0439926, 1, 0, 0.46922,-99) , 
5, 4.3492, 0, 0, 0.490463,-99) , 
5, 13.0373, 0, 0, 0.494817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468379,-99) , 
0, 0.0696435, 0, 0, 0.492481,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0470438);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458376,-99) , 
1, 4.21021, 1, 0, 0.477954,-99) , 
4, 3376.36, 0, 0, 0.507277,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522679,-99) , 
NN(
0, 
0, 
-1, 2.50569, 0, -1, 0.48507,-99) , 
13, 8.65765, 0, 0, 0.488371,-99) , 
10, 0.335336, 1, 0, 0.493163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467427,-99) , 
13, 11.3528, 1, 0, 0.490609,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0343739);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458156,-99) , 
10, 0.683542, 1, 0, 0.51906,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496068,-99) , 
10, 0.667668, 0, 0, 0.501955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465442,-99) , 
13, 11.3528, 1, 0, 0.498207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461051,-99) , 
4, 6232.41, 1, 0, 0.49555,-99) , 
4, 7264.27, 0, 0, 0.4979,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0342569);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529301,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488824,-99) , 
2, 2.85837, 1, 0, 0.497604,-99) , 
11, 12.1271, 0, 0, 0.50162,-99) , 
0, 0.535559, 0, 0, 0.504855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48175,-99) , 
0, 0.59197, 1, 0, 0.502997,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0235183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542081,-99) , 
NN(
NN(
0, 
0, 
-1, 1847.04, 1, 1, 0.507131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475813,-99) , 
13, 11.3528, 1, 0, 0.503992,-99) , 
11, 11.5515, 0, 0, 0.506466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47898,-99) , 
11, 16.1508, 1, 0, 0.504387,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
