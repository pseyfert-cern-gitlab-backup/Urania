// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/07       [336391]
Creator        : pseyfert
Date           : Fri Dec 20 21:32:54 2013
Host           : Linux lxbuild175.cern.ch 2.6.18-308.4.1.el5 #1 SMP Wed Apr 18 16:26:27 CEST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /auto/sigma0/pseyfert/zoontuple/Bender_v22r7/Phys/Tau23Mu/scripts/TMVA_training_v3
Training events: 41107
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
AdaBoostBeta: "5.000000e-01" [Parameter for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "1880" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "20" [Number of steps during node cut optimisation]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
MaxDepth: "4" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "4" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "41107" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 14
TMath::Exp(-1000*LifeTime)    TMath_Exp__M_1000_T_LifeTime_ TMath::Exp(-1000*LifeTime)    transformed decay time        1                                 'F'    [1.93987222119e-11,0.731256723404]
IPSig                         IPSig                         IPSig                         IP significance               1                                 'F'    [0.0111495917663,24.9779434204]
VertexChi2                    VertexChi2                    VertexChi2                    vertex #chi^{2}               1                                 'F'    [0.00189490010962,14.9983968735]
acos(dira)                    acos_dira_                    acos(dira)                    pointing angle                1                                 'F'    [0,0.137716650963]
pt                            pt                            pt                            p_{T}                         [MeV/c]                           'F'    [41.2933425903,37961.9179688]
Laura_SumBDT                  Laura_SumBDT                  Laura_SumBDT                  Laura_SumBDT                                                    'F'    [-2.57286167145,5]
min(p0_IPSig,min(p1_IPSig,p2_IPSig)) min_p0_IPSig,min_p1_IPSig,p2_IPSig__ min(p0_IPSig,min(p1_IPSig,p2_IPSig)) min. #mu IP significance             1                                        'F'    [2.30495882034,102.738922119]
DOCAone                       DOCAone                       DOCAone                       DOCA (#mu 1 and 2)            mm                                'F'    [2.63570382231e-06,0.923672735691]
DOCAtwo                       DOCAtwo                       DOCAtwo                       DOCA (#mu 2 and 3)            mm                                'F'    [2.4348450367e-08,0.744905769825]
DOCAthree                     DOCAthree                     DOCAthree                     DOCA (#mu 1 and 3)            mm                                'F'    [6.10736776707e-07,1.05343544483]
CDF3                          CDF3                          CDF3                          cone isolation                1                                 'F'    [0.00300450995564,1]
p0_track_MatchChi2            p0_track_MatchChi2            p0_track_MatchChi2            track match #chi^{2} (#mu 1)  1                                 'F'    [0.0559116005898,84.5542831421]
p1_track_MatchChi2            p1_track_MatchChi2            p1_track_MatchChi2            track match #chi^{2} (#mu 2)  1                                 'F'    [0.0131226135418,75.9046707153]
p2_track_MatchChi2            p2_track_MatchChi2            p2_track_MatchChi2            track match #chi^{2} (#mu 3)  1                                 'F'    [0.0151327997446,79.3785171509]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 14 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "TMath::Exp(-1000*LifeTime)", "IPSig", "VertexChi2", "acos(dira)", "pt", "Laura_SumBDT", "min(p0_IPSig,min(p1_IPSig,p2_IPSig))", "DOCAone", "DOCAtwo", "DOCAthree", "CDF3", "p0_track_MatchChi2", "p1_track_MatchChi2", "p2_track_MatchChi2" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 1.93987222119052e-11;
      fVmax[0] = 0.731256723403931;
      fVmin[1] = 0.0111495917662978;
      fVmax[1] = 24.9779434204102;
      fVmin[2] = 0.0018949001096189;
      fVmax[2] = 14.9983968734741;
      fVmin[3] = 0;
      fVmax[3] = 0.13771665096283;
      fVmin[4] = 41.293342590332;
      fVmax[4] = 37961.91796875;
      fVmin[5] = -2.57286167144775;
      fVmax[5] = 5;
      fVmin[6] = 2.30495882034302;
      fVmax[6] = 102.738922119141;
      fVmin[7] = 2.63570382230682e-06;
      fVmax[7] = 0.923672735691071;
      fVmin[8] = 2.43484503670288e-08;
      fVmax[8] = 0.744905769824982;
      fVmin[9] = 6.10736776707199e-07;
      fVmax[9] = 1.05343544483185;
      fVmin[10] = 0.00300450995564461;
      fVmax[10] = 1;
      fVmin[11] = 0.0559116005897522;
      fVmax[11] = 84.5542831420898;
      fVmin[12] = 0.0131226135417819;
      fVmax[12] = 75.904670715332;
      fVmin[13] = 0.015132799744606;
      fVmax[13] = 79.3785171508789;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[14];
   double fVmax[14];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[14];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1.24399648243804);
  fForest.push_back( 
NN(
0, 
0, 
-1, 0.0196738, 1, 1, 0.923296,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.742917);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0110478, 1, 1, 0.916929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 6.80805, 1, 1, 0.7316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487657,-99) , 
0, 0.343445, 1, 0, 0.656944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344409,-99) , 
2, 7.14107, 1, 0, 0.563304,-99) , 
1, 4.76673, 1, 0, 0.776259,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.570329);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.51619, 1, 1, 0.878355,-99) , 
NN(
NN(
0, 
0, 
-1, -0.614307, 1, 1, 0.636151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312426,-99) , 
2, 4.29437, 1, 0, 0.414847,-99) , 
3, 0.0190512, 1, 0, 0.559837,-99) , 
3, 0.00655794, 1, 0, 0.720735,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.404227);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.637171, 1, 1, 0.803232,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743144,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441833,-99) , 
6, 8.09355, 0, 0, 0.494208,-99) , 
1, 3.54492, 1, 0, 0.548993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50001,-99) , 
NN(
0, 
0, 
-1, 5.00298, 1, -1, 0.383306,-99) , 
6, 9.21265, 0, 0, 0.413914,-99) , 
5, -0.614307, 1, 0, 0.474533,-99) , 
3, 0.00655794, 1, 0, 0.6276,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.332295);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.677119, 1, 1, 0.831858,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0.00427459, 1, 1, 0.672022,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456999,-99) , 
0, 0.172943, 1, 0, 0.491519,-99) , 
1, 6.69162, 1, 0, 0.587844,-99) , 
NN(
0, 
0, 
-1, 0.348217, 0, -1, 0.421053,-99) , 
5, -0.512364, 1, 0, 0.521606,-99) , 
1, 2.38894, 1, 0, 0.602121,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.298045);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.677119, 1, 1, 0.780153,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 8.84241, 1, 1, 0.594018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424399,-99) , 
7, 0.0879717, 1, 0, 0.567621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33575,-99) , 
11, 12.1586, 1, 0, 0.53621,-99) , 
1, 2.38894, 1, 0, 0.595741,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.257568);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00401574, 1, 1, 0.859255,-99) , 
NN(
NN(
0, 
0, 
-1, 0.206095, 1, 1, 0.609213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409822,-99) , 
1, 7.55276, 1, 0, 0.516792,-99) , 
1, 3.1165, 1, 0, 0.680259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 4691.7, 0, 1, 0.542443,-99) , 
NN(
0, 
0, 
-1, 0.30693, 0, -1, 0.421846,-99) , 
11, 8.10338, 1, 0, 0.509127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336164,-99) , 
2, 9.99579, 1, 0, 0.482005,-99) , 
5, -0.769799, 1, 0, 0.554297,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.23873);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00401574, 1, 1, 0.825137,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471144,-99) , 
3, 0.00632428, 1, 0, 0.512439,-99) , 
1, 3.1165, 1, 0, 0.656211,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 2.40857, 1, 1, 0.584533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39565,-99) , 
6, 5.12502, 0, 0, 0.458967,-99) , 
4, 4229.67, 0, 0, 0.507762,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558118,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403281,-99) , 
0, 0.312578, 0, 0, 0.468192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338666,-99) , 
1, 4.7647, 0, 0, 0.42909,-99) , 
5, -0.495006, 1, 0, 0.467299,-99) , 
5, -0.769799, 1, 0, 0.534399,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.207513);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00401574, 1, 1, 0.787984,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0299957, 1, 1, 0.579273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465648,-99) , 
11, 6.93608, 1, 0, 0.538682,-99) , 
1, 3.1165, 1, 0, 0.649136,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441057,-99) , 
0, 0.313396, 0, 0, 0.477106,-99) , 
1, 3.15219, 1, 0, 0.510973,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435685,-99) , 
2, 6.83454, 0, 0, 0.477,-99) , 
NN(
0, 
0, 
-1, 6.29226, 1, -1, 0.359235,-99) , 
1, 4.80115, 0, 0, 0.433393,-99) , 
2, 3.57114, 1, 0, 0.464989,-99) , 
5, -0.769799, 1, 0, 0.529415,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.167328);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.793001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453038,-99) , 
5, -0.677119, 1, 0, 0.669153,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 5.6401, 1, 1, 0.58456,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455289,-99) , 
1, 8.84295, 1, 0, 0.491338,-99) , 
2, 1.43003, 1, 0, 0.505256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360803,-99) , 
0, 0.522326, 1, 0, 0.48526,-99) , 
1, 2.38894, 1, 0, 0.523603,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.136642);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00496557, 1, 1, 0.764188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494732,-99) , 
5, -0.677119, 1, 0, 0.663373,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490559,-99) , 
5, -0.881699, 1, 0, 0.510764,-99) , 
NN(
0, 
0, 
-1, 7.76729, 0, -1, 0.447182,-99) , 
12, 7.24089, 1, 0, 0.493117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400219,-99) , 
0, 0.522326, 1, 0, 0.480449,-99) , 
1, 2.38894, 1, 0, 0.517812,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.135306);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 5.71485, 1, 1, 0.839701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48346,-99) , 
5, -0.627752, 1, 0, 0.720893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478248,-99) , 
3, 0.00496557, 1, 0, 0.658404,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 4.8315, 0, 1, 0.535102,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458641,-99) , 
2, 2.65512, 1, 0, 0.48073,-99) , 
12, 7.24089, 1, 0, 0.520229,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44101,-99) , 
2, 9.28212, 1, 0, 0.505978,-99) , 
1, 2.38894, 1, 0, 0.536685,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.132774);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.03194, 1, 1, 0.729356,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.668292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451803,-99) , 
4, 4318.67, 0, 0, 0.531189,-99) , 
2, 5.71485, 1, 0, 0.662659,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545824,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481005,-99) , 
3, 0.00349304, 1, 0, 0.493939,-99) , 
3, 0.0183407, 0, 0, 0.507098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434743,-99) , 
0, 0.487504, 1, 0, 0.494246,-99) , 
1, 2.38894, 1, 0, 0.527663,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0983079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28024, 1, 1, 0.808928,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00428055, 1, 1, 0.637228,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496688,-99) , 
2, 6.42897, 1, 0, 0.596454,-99) , 
5, -1.03194, 1, 0, 0.647219,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.63453, 1, 1, 0.520444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463562,-99) , 
13, 11.3528, 1, 0, 0.514714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457468,-99) , 
0, 0.522326, 1, 0, 0.507038,-99) , 
1, 2.38894, 1, 0, 0.534417,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.100672);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.76262, 1, 1, 0.797067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492898,-99) , 
5, -0.627752, 1, 0, 0.690221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486773,-99) , 
3, 0.00496557, 1, 0, 0.635486,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553148,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479488,-99) , 
0, 0.348217, 0, 0, 0.495266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454587,-99) , 
8, 0.0709435, 1, 0, 0.488274,-99) , 
4, 7762.18, 0, 0, 0.493334,-99) , 
1, 2.38894, 1, 0, 0.520825,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.136155);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28024, 1, 1, 0.788126,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0215836, 1, 1, 0.644258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477462,-99) , 
0, 0.377306, 1, 0, 0.538447,-99) , 
7, 0.034858, 1, 0, 0.59367,-99) , 
5, -1.03194, 1, 0, 0.638826,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591153,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463344,-99) , 
1, 7.05691, 1, 0, 0.50739,-99) , 
2, 6.41244, 0, 0, 0.533882,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479839,-99) , 
6, 8.28868, 1, 0, 0.508816,-99) , 
NN(
0, 
0, 
-1, 4.24897, 0, -1, 0.447053,-99) , 
6, 5.44639, 0, 0, 0.482509,-99) , 
0, 0.20893, 1, 0, 0.499944,-99) , 
1, 2.38894, 1, 0, 0.526542,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.105725);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28024, 1, 1, 0.7645,-99) , 
NN(
NN(
0, 
0, 
-1, 0.484523, 1, 1, 0.619853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49873,-99) , 
0, 0.308382, 0, 0, 0.580131,-99) , 
5, -1.03194, 1, 0, 0.622116,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 1.43139, 1, 1, 0.531486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472457,-99) , 
5, -0.391159, 1, 0, 0.520011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414662,-99) , 
2, 5.71108, 1, 0, 0.476573,-99) , 
0, 0.417861, 1, 0, 0.507923,-99) , 
1, 2.38894, 1, 0, 0.529549,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.102961);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.76262, 1, 1, 0.758713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494517,-99) , 
5, -0.627752, 1, 0, 0.661561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478795,-99) , 
3, 0.00496557, 1, 0, 0.610518,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 4.25551, 1, 1, 0.53501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473357,-99) , 
0, 0.0696402, 0, 0, 0.516296,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477738,-99) , 
2, 4.28547, 0, 0, 0.501421,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418767,-99) , 
9, 0.0343437, 1, 0, 0.462396,-99) , 
1, 5.61597, 0, 0, 0.484562,-99) , 
0, 0.20893, 1, 0, 0.495295,-99) , 
1, 2.38894, 1, 0, 0.516954,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.103486);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.969652, 1, 1, 0.67589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427064,-99) , 
1, 1.67521, 0, 0, 0.534077,-99) , 
3, 0.00331038, 1, 0, 0.61427,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493654,-99) , 
1, 5.6401, 1, 0, 0.529804,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451132,-99) , 
3, 0.00688676, 0, 0, 0.501161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427449,-99) , 
2, 4.65944, 1, 0, 0.458947,-99) , 
1, 5.61595, 0, 0, 0.485668,-99) , 
2, 1.43003, 1, 0, 0.492055,-99) , 
1, 2.38894, 1, 0, 0.514852,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.100874);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28024, 1, 1, 0.734897,-99) , 
NN(
NN(
0, 
0, 
-1, -0.707239, 1, 1, 0.60633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421539,-99) , 
0, 0.411117, 0, 0, 0.49436,-99) , 
10, 0.572716, 1, 0, 0.564831,-99) , 
5, -1.03194, 1, 0, 0.601904,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492436,-99) , 
9, 0.0153703, 1, 0, 0.53825,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473114,-99) , 
10, 0.481496, 1, 0, 0.506557,-99) , 
NN(
0, 
0, 
-1, 4.43692, 0, -1, 0.468974,-99) , 
0, 0.139287, 1, 0, 0.476804,-99) , 
2, 1.43003, 1, 0, 0.485688,-99) , 
1, 2.38894, 1, 0, 0.50715,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.107921);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, -1.03194, 1, 1, 0.612138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41267,-99) , 
2, 9.28544, 1, 0, 0.578295,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453288,-99) , 
1, 4.89101, 0, 0, 0.497895,-99) , 
11, 8.5035, 0, 0, 0.510099,-99) , 
1, 3.1165, 1, 0, 0.528424,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390348,-99) , 
11, 16.1508, 1, 0, 0.517698,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0963507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.28024, 1, 1, 0.704125,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471818,-99) , 
5, -0.614479, 1, 0, 0.560865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456756,-99) , 
10, 0.667668, 1, 0, 0.535389,-99) , 
5, -1.03194, 1, 0, 0.5713,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487967,-99) , 
9, 0.034369, 1, 0, 0.526543,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441697,-99) , 
0, 0.265292, 1, 0, 0.489151,-99) , 
0, 0.348218, 0, 0, 0.504405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526516,-99) , 
NN(
0, 
0, 
-1, 0.0134258, 1, -1, 0.452172,-99) , 
4, 4270.83, 0, 0, 0.47031,-99) , 
10, 0.430729, 0, 0, 0.48899,-99) , 
1, 2.38894, 1, 0, 0.503957,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0898235);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 5.00368, 1, 1, 0.783647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483205,-99) , 
5, -0.622254, 1, 0, 0.55617,-99) , 
5, -0.969652, 1, 0, 0.612989,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469354,-99) , 
3, 0.00496557, 1, 0, 0.571598,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487841,-99) , 
1, 2.74748, 1, 0, 0.5288,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471025,-99) , 
1, 9.63928, 1, 0, 0.498439,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433932,-99) , 
4, 3121, 1, 0, 0.467058,-99) , 
8, 0.0354718, 1, 0, 0.485063,-99) , 
1, 3.46462, 1, 0, 0.491235,-99) , 
1, 2.38894, 1, 0, 0.505768,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.098928);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0201, 1, 1, 0.634709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458567,-99) , 
7, 0.0703428, 1, 0, 0.594046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468476,-99) , 
10, 0.576796, 0, 0, 0.493384,-99) , 
3, 0.00534187, 1, 0, 0.556658,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476025,-99) , 
5, -0.624596, 0, 0, 0.504671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460382,-99) , 
0, 0.138923, 1, 0, 0.475077,-99) , 
10, 0.437465, 0, 0, 0.488954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448706,-99) , 
10, 0.762804, 1, 0, 0.484131,-99) , 
1, 3.57783, 1, 0, 0.506387,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0895363);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.0147475, 1, 1, 0.689507,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498428,-99) , 
1, 1.53971, 1, 0, 0.546432,-99) , 
6, 7.98138, 0, 0, 0.582439,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480825,-99) , 
4, 4274.7, 0, 0, 0.541233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439195,-99) , 
13, 3.36566, 0, 0, 0.50355,-99) , 
2, 5.71485, 1, 0, 0.552688,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48704,-99) , 
6, 7.5524, 0, 0, 0.507084,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471831,-99) , 
0, 0.429488, 1, 0, 0.503569,-99) , 
NN(
0, 
0, 
-1, 2.13789, 1, -1, 0.455721,-99) , 
0, 0.243752, 0, 0, 0.482635,-99) , 
9, 0.0501642, 0, 0, 0.492041,-99) , 
1, 3.57783, 1, 0, 0.510584,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0913303);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 1.71975, 1, 1, 0.852132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484986,-99) , 
2, 4.28024, 1, 0, 0.641398,-99) , 
NN(
NN(
0, 
0, 
-1, 10.1585, 0, 1, 0.55979,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433426,-99) , 
0, 0.171977, 0, 0, 0.543177,-99) , 
5, -1.13041, 1, 0, 0.558501,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476188,-99) , 
4, 4029.7, 1, 0, 0.512845,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477354,-99) , 
4, 4717.47, 0, 0, 0.506721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459675,-99) , 
7, 0.0403127, 1, 0, 0.490652,-99) , 
9, 0.0501642, 0, 0, 0.499195,-99) , 
1, 3.57783, 1, 0, 0.517276,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0879652);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 4.27943, 1, 1, 0.671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463574,-99) , 
13, 7.57355, 1, 0, 0.531632,-99) , 
5, -1.13041, 1, 0, 0.552525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559575,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4826,-99) , 
13, 3.10273, 1, 0, 0.493475,-99) , 
11, 8.5035, 0, 0, 0.505458,-99) , 
1, 4.15161, 1, 0, 0.52233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427458,-99) , 
11, 16.1508, 1, 0, 0.514998,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0796018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.04627, 1, 1, 0.553927,-99) , 
NN(
NN(
0, 
0, 
-1, 0.398673, 1, 1, 0.529565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453346,-99) , 
1, 7.37143, 0, 0, 0.490113,-99) , 
0, 0.338241, 0, 0, 0.506194,-99) , 
5, -0.769799, 1, 0, 0.521602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439582,-99) , 
0, 0.59197, 1, 0, 0.515134,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0555785);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.13041, 1, 1, 0.53457,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486155,-99) , 
6, 7.26868, 1, 0, 0.502089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45768,-99) , 
1, 4.9896, 0, 0, 0.496955,-99) , 
1, 4.15161, 1, 0, 0.51039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438317,-99) , 
11, 16.1508, 1, 0, 0.504814,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0696846);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00384307, 1, 1, 0.615765,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487102,-99) , 
2, 7.14334, 0, 0, 0.510367,-99) , 
12, 2.61455, 1, 0, 0.532768,-99) , 
NN(
NN(
0, 
0, 
-1, 3.62252, 1, 1, 0.521196,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43592,-99) , 
1, 5.24503, 0, 0, 0.478256,-99) , 
12, 4.65839, 0, 0, 0.496973,-99) , 
5, -0.769799, 1, 0, 0.508428,-99) , 
NN(
0, 
0, 
-1, 0.481496, 1, -1, 0.455787,-99) , 
12, 10.8548, 1, 0, 0.502605,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0837353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690417,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48686,-99) , 
3, 0.00565444, 1, 0, 0.558293,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455215,-99) , 
13, 6.63056, 0, 0, 0.485989,-99) , 
7, 0.0299951, 1, 0, 0.518543,-99) , 
1, 1.04627, 1, 0, 0.528404,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485022,-99) , 
2, 3.7415, 0, 0, 0.514764,-99) , 
NN(
0, 
0, 
-1, 0.0473993, 1, -1, 0.479001,-99) , 
0, 0.348217, 0, 0, 0.494123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463705,-99) , 
2, 7.85424, 1, 0, 0.486323,-99) , 
5, -0.769799, 1, 0, 0.49984,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0686234);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, -0.855685, 1, 1, 0.60515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460701,-99) , 
10, 0.335336, 1, 0, 0.497482,-99) , 
9, 0.0352396, 1, 0, 0.547593,-99) , 
NN(
NN(
0, 
0, 
-1, 2691.29, 1, 1, 0.522729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458729,-99) , 
0, 0.343264, 0, 0, 0.492655,-99) , 
0, 0.278574, 1, 0, 0.507456,-99) , 
1, 3.15066, 1, 0, 0.517822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460656,-99) , 
2, 11.4278, 1, 0, 0.512443,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0720011);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.27943, 1, 1, 0.611719,-99) , 
NN(
NN(
0, 
0, 
-1, -0.926072, 1, 1, 0.528487,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413072,-99) , 
0, 0.313408, 0, 0, 0.473542,-99) , 
10, 0.572716, 1, 0, 0.510102,-99) , 
5, -1.13041, 1, 0, 0.523094,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514799,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436031,-99) , 
2, 2.0419, 1, 0, 0.459998,-99) , 
0, 0.340439, 0, 0, 0.477044,-99) , 
2, 7.13525, 0, 0, 0.486843,-99) , 
1, 5.95562, 1, 0, 0.504675,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0518712);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.750906,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498632,-99) , 
10, 0.382812, 1, 0, 0.517067,-99) , 
1, 1.04627, 1, 0, 0.528404,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453429,-99) , 
10, 0.667925, 1, 0, 0.496068,-99) , 
NN(
0, 
0, 
-1, 4.14797, 1, -1, 0.45945,-99) , 
0, 0.422801, 1, 0, 0.486736,-99) , 
5, -0.769799, 1, 0, 0.500043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433371,-99) , 
0, 0.59197, 1, 0, 0.494763,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0717561);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660765,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00511969, 1, 1, 0.552826,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511073,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413583,-99) , 
1, 3.01805, 0, 0, 0.482019,-99) , 
5, -0.941539, 1, 0, 0.5198,-99) , 
1, 1.04627, 1, 0, 0.527581,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522746,-99) , 
NN(
0, 
0, 
-1, 0.0593136, 1, -1, 0.481694,-99) , 
0, 0.338223, 0, 0, 0.489559,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51928,-99) , 
NN(
0, 
0, 
-1, 3.36858, 0, -1, 0.436242,-99) , 
13, 6.34182, 0, 0, 0.462772,-99) , 
0, 0.417861, 1, 0, 0.480836,-99) , 
5, -0.769799, 1, 0, 0.495731,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0651603);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669708,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46276,-99) , 
7, 0.0351724, 1, 0, 0.522084,-99) , 
13, 6.14936, 0, 0, 0.552317,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422944,-99) , 
13, 9.86242, 1, 0, 0.531546,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560657,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498008,-99) , 
9, 0.0247411, 1, 0, 0.51814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476677,-99) , 
5, -0.513626, 0, 0, 0.49022,-99) , 
13, 7.57355, 0, 0, 0.496824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458105,-99) , 
3, 0.0262317, 1, 0, 0.490985,-99) , 
1, 2.38894, 1, 0, 0.498031,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.068981);
  fForest.push_back( 
NN(
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401987,-99) , 
10, 0.857572, 1, 0, 0.578752,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433746,-99) , 
9, 0.0320106, 0, 0, 0.478417,-99) , 
3, 0.00534187, 1, 0, 0.539566,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559707,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449701,-99) , 
3, 0.00688676, 0, 0, 0.491759,-99) , 
6, 16.0334, 0, 0, 0.498299,-99) , 
1, 3.57783, 1, 0, 0.511698,-99) , 
NN(
0, 
0, 
-1, 0.312578, 1, -1, 0.469922,-99) , 
5, -0.409187, 1, 0, 0.50272,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0986737);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.028509, 1, 1, 0.596004,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421546,-99) , 
2, 6.90637, 0, 0, 0.50848,-99) , 
2, 5.00114, 1, 0, 0.556129,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480485,-99) , 
6, 5.14583, 1, 0, 0.527358,-99) , 
NN(
0, 
0, 
-1, 0.456196, 0, -1, 0.438774,-99) , 
6, 4.30689, 0, 0, 0.487229,-99) , 
6, 6.50952, 0, 0, 0.514365,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530688,-99) , 
NN(
0, 
0, 
-1, 4007.31, 1, -1, 0.478673,-99) , 
0, 0.193498, 0, 0, 0.498707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456349,-99) , 
0, 0.312578, 1, 0, 0.482614,-99) , 
1, 5.95562, 1, 0, 0.498177,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0645982);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574617,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562664,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49571,-99) , 
2, 2.85837, 1, 0, 0.518027,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458038,-99) , 
9, 0.0501933, 0, 0, 0.483744,-99) , 
3, 0.0131159, 1, 0, 0.505641,-99) , 
11, 11.5515, 0, 0, 0.510206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453121,-99) , 
11, 16.1508, 1, 0, 0.505783,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0380679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.969652, 1, 1, 0.578319,-99) , 
NN(
NN(
0, 
0, 
-1, -0.63357, 1, 1, 0.514798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487086,-99) , 
9, 0.100328, 1, 0, 0.510589,-99) , 
1, 1.20004, 1, 0, 0.513991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465694,-99) , 
0, 0.59197, 1, 0, 0.510184,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0738018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647888,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495014,-99) , 
3, 0.00511969, 1, 0, 0.542646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437817,-99) , 
5, -0.859698, 0, 0, 0.483518,-99) , 
5, -0.941539, 1, 0, 0.515049,-99) , 
1, 1.04627, 1, 0, 0.522101,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597206,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471878,-99) , 
4, 3245.79, 0, 0, 0.499969,-99) , 
1, 2.88286, 1, 0, 0.515196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484045,-99) , 
5, -0.486939, 0, 0, 0.500514,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407923,-99) , 
5, -0.498542, 1, 0, 0.456473,-99) , 
1, 4.76818, 0, 0, 0.485279,-99) , 
9, 0.0501642, 0, 0, 0.496636,-99) , 
5, -0.769799, 1, 0, 0.504701,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.070205);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.67857, 1, 1, 0.589206,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00384307, 1, 1, 0.563992,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473828,-99) , 
10, 0.385055, 1, 0, 0.494817,-99) , 
12, 2.94675, 1, 0, 0.511114,-99) , 
5, -1.28497, 1, 0, 0.52361,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579333,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473351,-99) , 
2, 5.09311, 0, 0, 0.499216,-99) , 
1, 2.88286, 1, 0, 0.511707,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478388,-99) , 
13, 3.22133, 0, 0, 0.498713,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424826,-99) , 
4, 4970.95, 0, 0, 0.455776,-99) , 
1, 4.76818, 0, 0, 0.483882,-99) , 
9, 0.0501642, 0, 0, 0.494439,-99) , 
5, -0.769799, 1, 0, 0.503668,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0957576);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00150463, 1, 1, 0.638009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486929,-99) , 
3, 0.00632428, 1, 0, 0.547722,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462969,-99) , 
10, 0.430288, 0, 0, 0.542385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400875,-99) , 
4, 4260.51, 1, 0, 0.489361,-99) , 
9, 0.0484335, 1, 0, 0.523647,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453485,-99) , 
0, 0.309529, 1, 0, 0.485082,-99) , 
11, 3.81949, 1, 0, 0.505616,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474996,-99) , 
3, 0.00638595, 1, 0, 0.497972,-99) , 
NN(
0, 
0, 
-1, 0.431037, 0, -1, 0.460515,-99) , 
5, -0.451629, 1, 0, 0.481486,-99) , 
9, 0.0501642, 0, 0, 0.490641,-99) , 
5, -0.769799, 1, 0, 0.501073,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.060056);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 3.58304, 1, 1, 0.621447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456521,-99) , 
10, 0.595874, 1, 0, 0.522398,-99) , 
10, 0.694722, 0, 0, 0.541101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460408,-99) , 
10, 0.857572, 1, 0, 0.530189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 5342.41, 0, 1, 0.512122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463093,-99) , 
4, 6590.33, 1, 0, 0.50514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475487,-99) , 
2, 7.85424, 1, 0, 0.497536,-99) , 
5, -0.769799, 1, 0, 0.507831,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0729302);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, -0.940256, 1, 1, 0.621175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438891,-99) , 
13, 5.79961, 1, 0, 0.502739,-99) , 
9, 0.0262772, 1, 0, 0.552833,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548654,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396836,-99) , 
11, 4.59525, 1, 0, 0.471281,-99) , 
11, 6.8593, 0, 0, 0.49522,-99) , 
7, 0.0351724, 1, 0, 0.524605,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517213,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538074,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464485,-99) , 
8, 0.0296569, 0, 0, 0.482686,-99) , 
0, 0.557148, 0, 0, 0.488923,-99) , 
7, 0.0879717, 0, 0, 0.493396,-99) , 
5, -0.769799, 1, 0, 0.50322,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0524291);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00331038, 1, 1, 0.694436,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455375,-99) , 
9, 0.0286374, 1, 0, 0.494577,-99) , 
1, 2.58936, 1, 0, 0.546064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538906,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467302,-99) , 
2, 6.42897, 1, 0, 0.491816,-99) , 
4, 7264.27, 0, 0, 0.496903,-99) , 
5, -0.997187, 1, 0, 0.503874,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426236,-99) , 
2, 7.43767, 0, 0, 0.465693,-99) , 
9, 0.100328, 1, 0, 0.49815,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0704307);
  fForest.push_back( 
NN(
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.727871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461014,-99) , 
9, 0.0398794, 1, 0, 0.610546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498008,-99) , 
3, 0.00565444, 1, 0, 0.538624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493624,-99) , 
2, 5.14173, 0, 0, 0.520236,-99) , 
NN(
0, 
0, 
-1, 2844.13, 0, -1, 0.459466,-99) , 
10, 0.577525, 0, 0, 0.484663,-99) , 
7, 0.0351724, 1, 0, 0.512123,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483281,-99) , 
5, -0.4985, 1, 0, 0.529398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448016,-99) , 
13, 3.104, 0, 0, 0.50305,-99) , 
NN(
0, 
0, 
-1, 2.10578, 0, -1, 0.477081,-99) , 
4, 4953.07, 0, 0, 0.484732,-99) , 
5, -0.769799, 1, 0, 0.493325,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0647372);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0.00331038, 1, 1, 0.685319,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478152,-99) , 
1, 4.05546, 1, 0, 0.506983,-99) , 
1, 2.58936, 1, 0, 0.552901,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467614,-99) , 
10, 0.76262, 1, 0, 0.512647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449033,-99) , 
1, 6.49392, 0, 0, 0.484313,-99) , 
2, 2.14425, 0, 0, 0.504359,-99) , 
5, -0.997187, 1, 0, 0.511216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428834,-99) , 
3, 0.00655794, 0, 0, 0.480599,-99) , 
9, 0.100328, 1, 0, 0.506635,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.079237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662834,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493192,-99) , 
9, 0.0224822, 1, 0, 0.527473,-99) , 
5, -1.28113, 1, 0, 0.547975,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464392,-99) , 
10, 0.624467, 0, 0, 0.514071,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451207,-99) , 
13, 3.37392, 0, 0, 0.491022,-99) , 
7, 0.0351724, 1, 0, 0.519997,-99) , 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492564,-99) , 
12, 6.20336, 0, 0, 0.521807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460959,-99) , 
13, 3.02238, 0, 0, 0.503264,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478403,-99) , 
1, 10.4895, 0, 0, 0.496444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452724,-99) , 
13, 6.4379, 1, 0, 0.48115,-99) , 
1, 5.95699, 1, 0, 0.49064,-99) , 
5, -0.769799, 1, 0, 0.499825,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0660772);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738957,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450051,-99) , 
2, 4.28024, 1, 0, 0.524878,-99) , 
13, 6.34709, 0, 0, 0.577673,-99) , 
NN(
NN(
0, 
0, 
-1, 3.5776, 0, 1, 0.537089,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438336,-99) , 
1, 3.86022, 1, 0, 0.501512,-99) , 
1, 4.76597, 0, 0, 0.512891,-99) , 
5, -1.13041, 1, 0, 0.520155,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492217,-99) , 
8, 0.0174508, 0, 0, 0.509159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473049,-99) , 
8, 0.0333059, 1, 0, 0.493341,-99) , 
1, 7.14452, 1, 0, 0.508585,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
