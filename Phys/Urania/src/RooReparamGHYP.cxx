/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooReparamGHYP.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "gsl/gsl_sf_bessel.h"


Double_t low_x_BK(Double_t nu,Double_t x){
  return TMath::Gamma(nu)*pow(2,nu-1)*pow(x,-nu);
}


Double_t low_x_LnBK(Double_t nu, Double_t x){
  return log(TMath::Gamma(nu)) + (nu-1)*log(2) - nu * log(x);
}

Double_t BK(Double_t ni, Double_t x) {
  Double_t nu = abs(ni);
  if ( x < 1e-06 && nu > 0) return low_x_BK(nu,x);
  if ( x < 1e-04 && nu > 0 && nu < 55) return low_x_BK(nu,x);
  if ( x < 0.1 && nu >= 55) return low_x_BK(nu,x);
 
  return gsl_sf_bessel_Knu(nu, x);
}

Double_t LnBK(double ni, double x) {
  Double_t nu = abs(ni);
  if ( x < 1e-06 && nu > 0) return low_x_LnBK(nu,x);
  if ( x < 1e-04 && nu > 0 && nu < 55) return low_x_LnBK(nu,x);
  if ( x < 0.1 && nu >= 55) return low_x_LnBK(nu,x);
  
  return gsl_sf_bessel_lnKnu(nu, x);
}




Double_t eval(Double_t x, Double_t l, Double_t alpha, Double_t beta, Double_t delta, Double_t mu) {
  Double_t sq2pi = sqrt(2*acos(-1));
  Double_t cons1 = 1./sq2pi;
  Double_t gamma = sqrt(alpha*alpha-beta*beta);
  Double_t dg = delta*gamma;
  //Double_t mu_ = mu;// - delta*beta*BK(l+1,dg)/(gamma*BK(l,dg));
  Double_t d = x-mu;
  Double_t thing = sqrt(delta*delta + d*d);
  Double_t no = pow(gamma/delta,l)/BK(l,dg)*cons1;
  Double_t num = no*BK(l-0.5,thing*alpha);
  Double_t den = pow(thing/alpha,0.5-l);
 return  exp(beta*d)*num/den ;
}

Double_t LogEval(Double_t x, Double_t l, Double_t alpha, Double_t beta, Double_t delta, Double_t mu) {
  Double_t d = x-mu;
  Double_t sq2pi = sqrt(2*acos(-1));
  Double_t gamma = sqrt(alpha*alpha-beta*beta);
  Double_t dg = delta*gamma;
  Double_t thing = delta*delta + d*d;
  Double_t logno = l*log(gamma/delta) - log(sq2pi) -LnBK(l, dg);
  return exp(logno + beta*d +(0.5-l)*(log(alpha)-0.5*log(thing)) + LnBK(l-0.5,alpha*sqrt(thing)) );

}

ClassImp(RooReparamGHYP) 

 RooReparamGHYP::RooReparamGHYP(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _l,
                        RooAbsReal& _zeta,
                        RooAbsReal& _fb,
                        RooAbsReal& _sigma,
                        RooAbsReal& _mu) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   l("l","l",this,_l),
   zeta("zeta","zeta",this,_zeta),
   fb("fb","fb",this,_fb),
   sigma("sigma","sigma",this,_sigma),
   mu("mu","mu",this,_mu)
 { 
 } 


 RooReparamGHYP::RooReparamGHYP(const RooReparamGHYP& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   l("l",this,other.l),
   zeta("zeta",this,other.zeta),
   fb("fb",this,other.fb),
   sigma("sigma",this,other.sigma),
   mu("mu",this,other.mu)
 { 
 } 



 Double_t RooReparamGHYP::evaluate() const 
 { 
   Double_t d = x-mu;
   Double_t cons0 = sqrt(zeta);
   Double_t alpha, beta, delta,  cons1, phi;
   
   if (zeta!= 0.) {
     phi = BK(l+1,zeta)/BK(l,zeta); // careful if zeta -> 0. You can implement a function for the ratio, but carefull again that |nu + 1 | != |nu| + 1 so you jave to deal wiht the signs
     cons1 = sigma/sqrt(phi);
     alpha  = cons0/(cons1*sqrt((1 - fb*fb)));
     beta = fb*alpha;
     //gamma = sqrt(alpha*alpha - beta*beta);
     delta = cons0*cons1; 
     return eval(x,l,alpha,beta,delta, mu);
     //return LogEval(x,l,alpha,beta,delta, mu);

   }
   else if (l < 0) {
     return  exp(beta*d)*pow(1 + d*d/(delta*delta),l-0.5);

   }
 } 



