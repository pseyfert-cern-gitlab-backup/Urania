/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory
 * Author: Paula Alvarez Cartelle, Antonio Yanez Santamaria                  * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "Kstar1D_gamma.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 


#define MPion 139.57018
#define MKaon 493.677
#define MMuon 105.65836668
#define MJPsi 3096.916
#define R 0.003


#include <vector>
using std::vector;

#include <iostream>
using std::ios;
#include <fstream>
#include <iomanip>
#include <sstream>

#include <complex>





Double_t phasespace(Double_t mass) {

if(mass<(MKaon+MPion)) return 0.;

Double_t phasesp = TMath::Sqrt(1.-2.*(MKaon*MKaon+MPion*MPion)/mass/mass + (MKaon*MKaon-MPion*MPion)*(MKaon*MKaon-MPion*MPion)/mass/mass/mass/mass); 

return phasesp;
//return 1;

}



// BW con anchura variable (depende de m)
std::complex<Double_t> BW(Double_t mass, Double_t mass0, Double_t Gamma0) {

  Double_t suma = (MPion+MKaon)*(MPion+MKaon)/(mass*mass);
  Double_t resta = (MPion-MKaon)*(MPion-MKaon)/(mass*mass);
  Double_t Km = mass/2.*TMath::Sqrt(1.-suma)*TMath::Sqrt(1.-resta);

  Double_t suma0 = (MPion+MKaon)*(MPion+MKaon)/(mass0*mass0);
  Double_t resta0 = (MPion-MKaon)*(MPion-MKaon)/(mass0*mass0);
  Double_t Km0 = mass0/2.*TMath::Sqrt(1.-suma0)*TMath::Sqrt(1.-resta0);
  

  Double_t Fm = 1./(1+R*R*Km*Km);
  Double_t Fm0 = 1./(1+R*R*Km0*Km0);

  Double_t Gamma = Gamma0*(mass0/mass)*(Km/Km0)*(Km/Km0)*(Km/Km0)*(Fm/Fm0);

  std::complex<Double_t> denom(mass*mass-mass0*mass0,-Gamma*mass0);

  Double_t nu = TMath::Sqrt(mass0*mass0*(mass0*mass0+Gamma*Gamma));
  std::complex<Double_t> k(TMath::Sqrt(2.*TMath::Sqrt(2.)*mass0*Gamma*nu/TMath::Pi()/TMath::Sqrt(mass0*mass0+nu)),0.);

  return k/denom;

}


ClassImp(Kstar1D_gamma) 

 Kstar1D_gamma::Kstar1D_gamma(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _alpha,
                        RooAbsReal& _beta,
                        RooAbsReal& _phase,
                        RooAbsReal& _mlo,
                        RooAbsReal& _mhi,
                        RooAbsReal& _gammalo,
                        RooAbsReal& _gammahi) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   alpha("alpha","alpha",this,_alpha),
   beta("beta","beta",this,_beta),
   phase("phase","phase",this,_phase),
   mlo("mlo","mlo",this,_mlo),
   mhi("mhi","mhi",this,_mhi),
   gammalo("gammalo","gammalo",this,_gammalo),
   gammahi("gammahi","gammahi",this,_gammahi)
 { 
 } 


 Kstar1D_gamma::Kstar1D_gamma(const Kstar1D_gamma& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   alpha("alpha",this,other.alpha),
   beta("beta",this,other.beta),
   phase("phase",this,other.phase),
   mlo("mlo",this,other.mlo),
   mhi("mhi",this,other.mhi),
   gammalo("gammalo",this,other.gammalo),
   gammahi("gammahi",this,other.gammahi)
 { 
 } 



 Double_t Kstar1D_gamma::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 


   // pdf kstar

   std::complex<Double_t> uno;
   std::complex<Double_t> dos(alpha, 0.);
   std::complex<Double_t> tres( beta*TMath::Cos(phase),beta*TMath::Sin(phase));

   uno = dos*BW(m,mlo,gammalo) + tres*BW(m,mhi,gammahi);
   //std::complex<Double_t> cuatro = dos*BW(m,mlo,gammalo);

   Double_t  kst1 = real(uno*conj(uno));
   Double_t  pdf1 = kst1*phasespace(m);


   return pdf1;



 } 

