/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "Kmatrix_nonRes.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#define MPion 493.667//139.57018
#define MKaon 493.667

#include <vector>
using std::vector;

#include <iostream>
using std::ios;
#include <fstream>
#include <iomanip>
#include <sstream>

#include <complex>
#include "BWtools.C"



ClassImp(Kmatrix_nonRes) 

 Kmatrix_nonRes::Kmatrix_nonRes(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _M0,
                        RooAbsReal& _gamma,
                        RooAbsReal& _kappa,
                        RooAbsReal& _phi,
                        RooAbsReal& _MB,
                        RooAbsReal& _MV,
                        RooAbsReal& _J) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   M0("M0","M0",this,_M0),
   gamma("gamma","gamma",this,_gamma),
   kappa("kappa","kappa",this,_kappa),
   phi("phi","phi",this,_phi),
   MB("MB","MB",this,_MB),
   MV("MV","MV",this,_MV),
   J("J","J",this,_J)
 { 
 } 


 Kmatrix_nonRes::Kmatrix_nonRes(const Kmatrix_nonRes& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   M0("M0",this,other.M0),
   gamma("gamma",this,other.gamma),
   kappa("kappa",this,other.kappa),
   phi("phi",this,other.phi),
   MB("MB",this,other.MB),
   MV("MV",this,other.MV),
   J("J",this,other.J)
 { 
 } 



 Double_t Kmatrix_nonRes::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //std::complex<Double_t> c1(kappa*cos(phi),kappa*sin(phi));
   Double_t K0 = get_K(m,M0,gamma,MKaon,MPion,J);
   //Double_t K1 = get_K(m,M1,gamma1,MKaon,MPion,J);
   //Double_t K2 = get_K(m,M2,gamma2,MKaon,MPion,J);
   Double_t K0h = get_K_hat(m,M0,gamma,MKaon,MPion,J);
   // Double_t K1h = c1*get_K_hat(m,M1,gamma1,MKaon,MPion,J);
   //Double_t K2h = c2*get_K_hat(m,M2,gamma2,MKaon,MPion,J);

   //Double_t rho = 2.*pow(get_q(m,MPion,MKaon),2*J+1)/m;
   Double_t rho = 2.*pow(get_q(m,MPion,MKaon)/m,2*J+1);

   std::complex<Double_t> num(K0h+kappa,0.); 
   std::complex<Double_t> den(1, -(K0 + kappa*rho)); 
   std::complex<Double_t> T = num/den;
   Double_t  kst1 = real(T*conj(T));
   kst1 = kst1 * rho;
   //kst1 = kst1*pow(get_q(m,MPion,MKaon),2*J+1);
   return kst1*get_q(MB,MV,m);
   //std::complex<Double_t> T = T_ResonancePlusNonR_K(m,M0,gamma,MPion,MKaon,c1, J);
   //Double_t  kst1 = real(T*conj(T));
   //kst1 = kst1*pow(get_q(m,MPion,MKaon),2*J+1);
   return kst1*get_q(MB,MV,m);
 } 




