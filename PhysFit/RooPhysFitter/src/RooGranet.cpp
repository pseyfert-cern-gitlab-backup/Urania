/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// BEGIN_HTML
// P.D.F. to model the background of the D*-D0 mass difference. 
// Similar to RooDstD0Bg PDF, but without a linear component (B=0).
// Also, the coefficients are labelled slightly differently (A->B, C->1/B)
// END_HTML
//

#include "Riostream.h"
 
#include <cmath> 
#include "TMath.h" 

#include "RooAbsReal.h" 
#include "RooRealVar.h"
#include "RooIntegrator1D.h"
#include "RooAbsFunc.h"

#include "RooPhysFitter/RooGranet.h" 

//ClassImp(RooGranet);

RooGranet::RooGranet(const char *name, const char *title, 
                     RooAbsReal& _x,
                     RooAbsReal& _x0,
                     RooAbsReal& _A,
                     RooAbsReal& _B) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  x0("x0","x0",this,_x0),
  A("A","A",this,_A),
  B("B","B",this,_B)
{ 
} 


RooGranet::RooGranet(const RooGranet& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  x0("x0",this,other.x0),
  A("A",this,other.A),
  B("B",this,other.B)
{ 
}


Double_t RooGranet::evaluate() const 
{ 
  Double_t arg= x - x0;
  Double_t expo = exp(-1*A*x);
  if (arg <= 0 ) 
    return 0;
  else if(B == 0)
    return expo;
  
  Double_t val= expo*TMath::Power(arg,B);
  
  return (val > 0 ? val : 0) ;
}

 
Int_t RooGranet::getAnalyticalIntegral(RooArgSet& /*allVars*/,
                                       RooArgSet& /*analVars*/,
                                       const char* /*rangeName*/) const  
{ 
   // if (matchArgs(allVars,analVars,x)) return 1 ; 
   return 0 ; 
} 


Double_t RooGranet::analyticalIntegral(Int_t code, 
                                       const char* rangeName) const  
{ 
  assert(code==1) ;  
  (void)code;

  Double_t min = x.min(rangeName);
  Double_t max = x.max(rangeName);
  if (max<=x0) return 0;
  if (min<x0) min=x0; // since the function is zero below x0
  if (B==0) { 
    return A*exp(A*x0)*( exp(-1*A*min) - exp(-1*A*max) );
  }
  // for B!=0, we can integrate analytically using the incomplete Gamma
  // function (TMath::Gamma(B+1,A(x-x0)))
  // Note that this is not valid for B<-1

  RooArgSet vset(x.arg(), "vset");
  RooAbsFunc* func = bindVars(vset);
  RooIntegrator1D integrator(*func, min, max);
  return integrator.integral();
} 



